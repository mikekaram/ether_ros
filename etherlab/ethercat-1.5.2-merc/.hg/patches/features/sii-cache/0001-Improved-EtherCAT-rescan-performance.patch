From: Knud Baastrup <kba@deif.com>
Date: Thu, 29 Jan 2015 11:39:31 +0100

Improved EtherCAT rescan performance.

The SII data and PDOs will now be re-used after a re-scan when the
EtherCAT master is in its operation phase. The SII data and PDOs will be
detached from the slaves prior to a scanning and re-attached during the
scanning without the need to fetch the SII data and PDOs once again.
The SII data and PDOs will however only be re-used if the slave can
match either the alias or the combination of vendor id, product code and
serial number for some already stored SII data.
* * *
Fix to ensure that master bails out if no SII data is available. Master
could previously get stucked in the same state in fsm_slave_config
and spam syslog.

diff --git a/master/fsm_coe.c b/master/fsm_coe.c
--- a/master/fsm_coe.c
+++ b/master/fsm_coe.c
@@ -351,13 +351,20 @@ void ec_fsm_coe_dict_start(
 {
     ec_slave_t *slave = fsm->slave;
 
-    if (!(slave->sii.mailbox_protocols & EC_MBOX_COE)) {
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave cannot process CoE dictionary request."
+                " SII data not available.\n");
+        fsm->state = ec_fsm_coe_error;
+        return;
+    }
+
+    if (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_COE)) {
         EC_SLAVE_ERR(slave, "Slave does not support CoE!\n");
         fsm->state = ec_fsm_coe_error;
         return;
     }
 
-    if (slave->sii.has_general && !slave->sii.coe_details.enable_sdo_info) {
+    if (slave->sii_image->sii.has_general && !slave->sii_image->sii.coe_details.enable_sdo_info) {
         EC_SLAVE_ERR(slave, "Slave does not support"
                 " SDO information service!\n");
         fsm->state = ec_fsm_coe_error;
@@ -1487,7 +1494,15 @@ void ec_fsm_coe_down_start(
         ec_print_data(request->data, request->data_size);
     }
 
-    if (!(slave->sii.mailbox_protocols & EC_MBOX_COE)) {
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave cannot process CoE download request."
+                " SII data not available.\n");
+        request->errno = EAGAIN;
+        fsm->state = ec_fsm_coe_error;
+        return;
+    }
+
+    if (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_COE)) {
         EC_SLAVE_ERR(slave, "Slave does not support CoE!\n");
         request->errno = EPROTONOSUPPORT;
         fsm->state = ec_fsm_coe_error;
@@ -2178,7 +2193,15 @@ void ec_fsm_coe_up_start(
     EC_SLAVE_DBG(slave, 1, "Uploading SDO 0x%04X:%02X.\n",
             request->index, request->subindex);
 
-    if (!(slave->sii.mailbox_protocols & EC_MBOX_COE)) {
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave cannot process CoE upload request."
+                " SII data not available.\n");
+        request->errno = EAGAIN;
+        fsm->state = ec_fsm_coe_error;
+        return;
+    }
+
+    if (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_COE)) {
         EC_SLAVE_ERR(slave, "Slave does not support CoE!\n");
         request->errno = EPROTONOSUPPORT;
         fsm->state = ec_fsm_coe_error;
diff --git a/master/fsm_eoe.c b/master/fsm_eoe.c
--- a/master/fsm_eoe.c
+++ b/master/fsm_eoe.c
@@ -264,7 +264,13 @@ void ec_fsm_eoe_set_ip_start(
 
     EC_SLAVE_DBG(slave, 1, "Setting IP parameters.\n");
 
-    if (!(slave->sii.mailbox_protocols & EC_MBOX_EOE)) {
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave not ready to execute EoE FSM\n");
+        fsm->state = ec_fsm_eoe_error;
+        return;
+    }
+
+    if (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_EOE)) {
         EC_SLAVE_ERR(slave, "Slave does not support EoE!\n");
         fsm->state = ec_fsm_eoe_error;
         return;
diff --git a/master/fsm_foe.c b/master/fsm_foe.c
--- a/master/fsm_foe.c
+++ b/master/fsm_foe.c
@@ -330,7 +330,14 @@ void ec_fsm_foe_write_start(
     EC_SLAVE_DBG(fsm->slave, 0, "%s()\n", __func__);
 #endif
 
-    if (!(slave->sii.mailbox_protocols & EC_MBOX_FOE)) {
+    if (!slave->sii_image) {
+        ec_foe_set_tx_error(fsm, FOE_BUSY);
+        EC_SLAVE_ERR(slave, "Slave cannot process FoE write request."
+                " SII data not available.\n");
+        return;
+    }
+
+    if (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_FOE)) {
         ec_foe_set_tx_error(fsm, FOE_MBOX_PROT_ERROR);
         EC_SLAVE_ERR(slave, "Slave does not support FoE!\n");
         return;
@@ -763,8 +770,15 @@ void ec_fsm_foe_read_start(
     EC_SLAVE_DBG(fsm->slave, 0, "%s()\n", __func__);
 #endif
 
-    if (!(slave->sii.mailbox_protocols & EC_MBOX_FOE)) {
-        ec_foe_set_tx_error(fsm, FOE_MBOX_PROT_ERROR);
+    if (!slave->sii_image) {
+        ec_foe_set_rx_error(fsm, FOE_BUSY);
+        EC_SLAVE_ERR(slave, "Slave cannot process FoE read request."
+                " SII data not available.\n");
+        return;
+    }
+
+    if (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_FOE)) {
+        ec_foe_set_rx_error(fsm, FOE_MBOX_PROT_ERROR);
         EC_SLAVE_ERR(slave, "Slave does not support FoE!\n");
         return;
     }
diff --git a/master/fsm_master.c b/master/fsm_master.c
--- a/master/fsm_master.c
+++ b/master/fsm_master.c
@@ -293,6 +293,7 @@ void ec_fsm_master_state_broadcast(
         ec_master_clear_eoe_handlers(master);
 #endif
         ec_master_clear_slaves(master);
+        ec_master_clear_sii_images(master);
 
         for (dev_idx = EC_DEVICE_MAIN;
                 dev_idx < ec_master_num_devices(master); dev_idx++) {
@@ -347,6 +348,7 @@ void ec_fsm_master_state_broadcast(
             ec_master_clear_eoe_handlers(master);
 #endif
             ec_master_clear_slaves(master);
+            ec_master_clear_sii_images(master);
 
             for (dev_idx = EC_DEVICE_MAIN;
                     dev_idx < ec_master_num_devices(master); dev_idx++) {
@@ -554,17 +556,17 @@ void ec_fsm_master_action_idle(
             slave < master->slaves + master->slave_count;
             slave++) {
 #if !EC_SKIP_SDO_DICT
-        if (!(slave->sii.mailbox_protocols & EC_MBOX_COE)
-                || (slave->sii.has_general
-                    && !slave->sii.coe_details.enable_sdo_info)
+        if (slave->sii_image && (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_COE)
+                || (slave->sii_image->sii.has_general
+                    && !slave->sii_image->sii.coe_details.enable_sdo_info)
                 || slave->sdo_dictionary_fetched
                 || slave->current_state == EC_SLAVE_STATE_INIT
                 || slave->current_state == EC_SLAVE_STATE_UNKNOWN
                 || jiffies - slave->jiffies_preop < EC_WAIT_SDO_DICT * HZ
-                ) {
-            if (!(slave->sii.mailbox_protocols & EC_MBOX_COE)
-                    || (slave->sii.has_general
-                        && !slave->sii.coe_details.enable_sdo_info)
+                )) {
+            if (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_COE)
+                    || (slave->sii_image->sii.has_general
+                        && !slave->sii_image->sii.coe_details.enable_sdo_info)
                     ){
 #endif
                 // SDO info not supported. Enable processing of requests
@@ -1113,7 +1115,7 @@ void ec_fsm_master_state_scan_slave(
     fsm->slave->valid_mbox_data = 1;
 
 #ifdef EC_EOE
-    if (slave->sii.mailbox_protocols & EC_MBOX_EOE) {
+    if (slave->sii_image && (slave->sii_image->sii.mailbox_protocols & EC_MBOX_EOE)) {
         // create EoE handler for this slave
         ec_eoe_t *eoe;
         if (!(eoe = kmalloc(sizeof(ec_eoe_t), GFP_KERNEL))) {
@@ -1520,9 +1522,15 @@ void ec_fsm_master_state_write_sii(
 
     if (request->offset <= 4 && request->offset + request->nwords > 4) {
         // alias was written
-        slave->sii.alias = EC_READ_U16(request->words + 4);
-        // TODO: read alias from register 0x0012
-        slave->effective_alias = slave->sii.alias;
+        if (slave->sii_image) {
+            slave->sii_image->sii.alias = EC_READ_U16(request->words + 4);
+            // TODO: read alias from register 0x0012
+            slave->effective_alias = slave->sii_image->sii.alias;
+        }
+        else {
+            EC_SLAVE_WARN(slave, "Slave could not update effective alias."
+                    " SII data not available.\n");
+        }
     }
     // TODO: Evaluate other SII contents!
 
diff --git a/master/fsm_pdo.c b/master/fsm_pdo.c
--- a/master/fsm_pdo.c
+++ b/master/fsm_pdo.c
@@ -528,27 +528,31 @@ void ec_fsm_pdo_conf_action_check_mappin
         ec_datagram_t *datagram /**< Datagram to use. */
         )
 {
-    // check, if slave supports PDO configuration
-    if ((fsm->slave->sii.mailbox_protocols & EC_MBOX_COE)
-            && fsm->slave->sii.has_general
-            && fsm->slave->sii.coe_details.enable_pdo_configuration) {
+    if (fsm->slave->sii_image) {
+        // check, if slave supports PDO configuration
+        if ((fsm->slave->sii_image->sii.mailbox_protocols & EC_MBOX_COE)
+                && fsm->slave->sii_image->sii.has_general
+                && fsm->slave->sii_image->sii.coe_details.enable_pdo_configuration) {
 
-        // always write PDO mapping
-        ec_fsm_pdo_entry_start_configuration(&fsm->fsm_pdo_entry, fsm->slave,
-                fsm->pdo, &fsm->slave_pdo);
-        fsm->state = ec_fsm_pdo_conf_state_mapping;
-        fsm->state(fsm, datagram); // execure immediately
-        return;
-    }
-    else if (!ec_pdo_equal_entries(fsm->pdo, &fsm->slave_pdo)) {
-        EC_SLAVE_WARN(fsm->slave, "Slave does not support"
-                " changing the PDO mapping!\n");
-        EC_SLAVE_WARN(fsm->slave, "");
-        printk(KERN_CONT "Currently mapped PDO entries: ");
-        ec_pdo_print_entries(&fsm->slave_pdo);
-        printk(KERN_CONT ". Entries to map: ");
-        ec_pdo_print_entries(fsm->pdo);
-        printk(KERN_CONT "\n");
+            // always write PDO mapping
+            ec_fsm_pdo_entry_start_configuration(&fsm->fsm_pdo_entry, fsm->slave,
+                    fsm->pdo, &fsm->slave_pdo);
+            fsm->state = ec_fsm_pdo_conf_state_mapping;
+            fsm->state(fsm, datagram); // execure immediately
+            return;
+        } else if (!ec_pdo_equal_entries(fsm->pdo, &fsm->slave_pdo)) {
+            EC_SLAVE_WARN(fsm->slave, "Slave does not support"
+                    " changing the PDO mapping!\n");
+            EC_SLAVE_WARN(fsm->slave, "");
+            printk(KERN_CONT "Currently mapped PDO entries: ");
+            ec_pdo_print_entries(&fsm->slave_pdo);
+            printk(KERN_CONT ". Entries to map: ");
+            ec_pdo_print_entries(fsm->pdo);
+            printk(KERN_CONT "\n");
+        } 
+    } else {
+        EC_SLAVE_ERR(fsm->slave, "Slave cannot do PDO mapping."
+                " SII data not available.\n");
     }
 
     ec_fsm_pdo_conf_action_next_pdo_mapping(fsm, datagram);
@@ -603,39 +607,45 @@ void ec_fsm_pdo_conf_action_check_assign
         ec_datagram_t *datagram /**< Datagram to use. */
         )
 {
-    if ((fsm->slave->sii.mailbox_protocols & EC_MBOX_COE)
-            && fsm->slave->sii.has_general
-            && fsm->slave->sii.coe_details.enable_pdo_assign) {
+    if (fsm->slave->sii_image) {
+        if ((fsm->slave->sii_image->sii.mailbox_protocols & EC_MBOX_COE)
+                && fsm->slave->sii_image->sii.has_general
+                && fsm->slave->sii_image->sii.coe_details.enable_pdo_assign) {
 
-        // always write PDO assignment
-        if (fsm->slave->master->debug_level) {
-            EC_SLAVE_DBG(fsm->slave, 1, "Setting PDO assignment of SM%u:\n",
-                    fsm->sync_index);
-            EC_SLAVE_DBG(fsm->slave, 1, ""); ec_fsm_pdo_print(fsm);
-        }
+            // always write PDO assignment
+            if (fsm->slave->master->debug_level) {
+                EC_SLAVE_DBG(fsm->slave, 1, "Setting PDO assignment of SM%u:\n",
+                        fsm->sync_index);
+                EC_SLAVE_DBG(fsm->slave, 1, ""); ec_fsm_pdo_print(fsm);
+            }
 
-        if (ec_sdo_request_alloc(&fsm->request, 2)) {
-            fsm->state = ec_fsm_pdo_state_error;
+            if (ec_sdo_request_alloc(&fsm->request, 2)) {
+                fsm->state = ec_fsm_pdo_state_error;
+                return;
+            }
+
+            // set mapped PDO count to zero
+            EC_WRITE_U8(fsm->request.data, 0); // zero PDOs mapped
+            fsm->request.data_size = 1;
+            ecrt_sdo_request_index(&fsm->request, 0x1C10 + fsm->sync_index, 0);
+            ecrt_sdo_request_write(&fsm->request);
+
+            EC_SLAVE_DBG(fsm->slave, 1, "Setting number of assigned"
+                    " PDOs to zero.\n");
+
+            fsm->state = ec_fsm_pdo_conf_state_zero_pdo_count;
+            ec_fsm_coe_transfer(fsm->fsm_coe, fsm->slave, &fsm->request);
+            ec_fsm_coe_exec(fsm->fsm_coe, datagram); // execute immediately
             return;
         }
-
-        // set mapped PDO count to zero
-        EC_WRITE_U8(fsm->request.data, 0); // zero PDOs mapped
-        fsm->request.data_size = 1;
-        ecrt_sdo_request_index(&fsm->request, 0x1C10 + fsm->sync_index, 0);
-        ecrt_sdo_request_write(&fsm->request);
-
-        EC_SLAVE_DBG(fsm->slave, 1, "Setting number of assigned"
-                " PDOs to zero.\n");
-
-        fsm->state = ec_fsm_pdo_conf_state_zero_pdo_count;
-        ec_fsm_coe_transfer(fsm->fsm_coe, fsm->slave, &fsm->request);
-        ec_fsm_coe_exec(fsm->fsm_coe, datagram); // execute immediately
-        return;
+        else if (!ec_pdo_list_equal(&fsm->sync->pdos, &fsm->pdos)) {
+            EC_SLAVE_WARN(fsm->slave, "Slave does not support assigning PDOs!\n");
+            EC_SLAVE_WARN(fsm->slave, ""); ec_fsm_pdo_print(fsm);
+        }
     }
-    else if (!ec_pdo_list_equal(&fsm->sync->pdos, &fsm->pdos)) {
-        EC_SLAVE_WARN(fsm->slave, "Slave does not support assigning PDOs!\n");
-        EC_SLAVE_WARN(fsm->slave, ""); ec_fsm_pdo_print(fsm);
+    else {
+        EC_SLAVE_ERR(fsm->slave, "Slave cannot do PDO assignment."
+                " SII data not available.\n");
     }
 
     ec_fsm_pdo_conf_action_next_sync(fsm, datagram);
diff --git a/master/fsm_slave.c b/master/fsm_slave.c
--- a/master/fsm_slave.c
+++ b/master/fsm_slave.c
@@ -634,9 +634,17 @@ int ec_fsm_slave_action_process_dict(
     request = list_entry(slave->dict_requests.next, ec_dict_request_t, list);
     list_del_init(&request->list); // dequeue
 
-    if (!(slave->sii.mailbox_protocols & EC_MBOX_COE)
-            || (slave->sii.has_general
-                && !slave->sii.coe_details.enable_sdo_info))
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave not ready to process dictionary request\n");
+        request->state = EC_INT_REQUEST_FAILURE;
+        wake_up_all(&slave->master->request_queue);
+        fsm->state = ec_fsm_slave_state_idle;
+        return 1;
+    }
+
+    if (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_COE)
+            || (slave->sii_image->sii.has_general
+                && !slave->sii_image->sii.coe_details.enable_sdo_info))
     {
         EC_SLAVE_INFO(slave, "Aborting dictionary request,"
                         " slave does not support SDO Info.\n");
diff --git a/master/fsm_slave_config.c b/master/fsm_slave_config.c
--- a/master/fsm_slave_config.c
+++ b/master/fsm_slave_config.c
@@ -441,7 +441,14 @@ void ec_fsm_slave_config_enter_mbox_sync
         return;
     }
 
-    if (!slave->sii.mailbox_protocols) {
+    if (!slave->sii_image) {
+        fsm->state = ec_fsm_slave_config_state_error;
+        EC_SLAVE_ERR(slave, "Slave cannot configure SyncManager."
+                " SII data not available.\n");
+        return;
+    }
+
+    if (!slave->sii_image->sii.mailbox_protocols) {
         // no mailbox protocols supported
         EC_SLAVE_DBG(slave, 1, "Slave does not support"
                 " mailbox communication.\n");
@@ -463,52 +470,57 @@ void ec_fsm_slave_config_enter_mbox_sync
         ec_datagram_zero(datagram);
 
         ec_sync_init(&sync, slave);
-        sync.physical_start_address = slave->sii.boot_rx_mailbox_offset;
+        sync.physical_start_address = slave->sii_image->sii.boot_rx_mailbox_offset;
         sync.control_register = 0x26;
         sync.enable = 1;
-        ec_sync_page(&sync, 0, slave->sii.boot_rx_mailbox_size,
+        ec_sync_page(&sync, 0, slave->sii_image->sii.boot_rx_mailbox_size,
                 EC_DIR_INVALID, // use default direction
                 0, // no PDO xfer
                 datagram->data);
         slave->configured_rx_mailbox_offset =
-            slave->sii.boot_rx_mailbox_offset;
+            slave->sii_image->sii.boot_rx_mailbox_offset;
         slave->configured_rx_mailbox_size =
-            slave->sii.boot_rx_mailbox_size;
+            slave->sii_image->sii.boot_rx_mailbox_size;
 
         ec_sync_init(&sync, slave);
-        sync.physical_start_address = slave->sii.boot_tx_mailbox_offset;
+        sync.physical_start_address = slave->sii_image->sii.boot_tx_mailbox_offset;
         sync.control_register = 0x22;
         sync.enable = 1;
-        ec_sync_page(&sync, 1, slave->sii.boot_tx_mailbox_size,
+        ec_sync_page(&sync, 1, slave->sii_image->sii.boot_tx_mailbox_size,
                 EC_DIR_INVALID, // use default direction
                 0, // no PDO xfer
                 datagram->data + EC_SYNC_PAGE_SIZE);
         slave->configured_tx_mailbox_offset =
-            slave->sii.boot_tx_mailbox_offset;
+            slave->sii_image->sii.boot_tx_mailbox_offset;
         slave->configured_tx_mailbox_size =
-            slave->sii.boot_tx_mailbox_size;
+            slave->sii_image->sii.boot_tx_mailbox_size;
 
-    } else if (slave->sii.sync_count >= 2) { // mailbox configuration provided
+    } else if (slave->sii_image->sii.sync_count >= 2) { // mailbox configuration provided
         ec_datagram_fpwr(datagram, slave->station_address, 0x0800,
-                EC_SYNC_PAGE_SIZE * slave->sii.sync_count);
+                EC_SYNC_PAGE_SIZE * slave->sii_image->sii.sync_count);
         ec_datagram_zero(datagram);
 
-        for (i = 0; i < 2; i++) {
-            ec_sync_page(&slave->sii.syncs[i], i,
-                    slave->sii.syncs[i].default_length,
-                    NULL, // use default sync manager configuration
-                    0, // no PDO xfer
-                    datagram->data + EC_SYNC_PAGE_SIZE * i);
+        if (slave->sii_image->sii.syncs) {
+            for (i = 0; i < 2; i++) {
+                ec_sync_page(&slave->sii_image->sii.syncs[i], i,
+                        slave->sii_image->sii.syncs[i].default_length,
+                        NULL, // use default sync manager configuration
+                        0, // no PDO xfer
+                        datagram->data + EC_SYNC_PAGE_SIZE * i);
+            }
+
+            slave->configured_rx_mailbox_offset =
+                slave->sii_image->sii.syncs[0].physical_start_address;
+            slave->configured_rx_mailbox_size =
+                slave->sii_image->sii.syncs[0].default_length;
+            slave->configured_tx_mailbox_offset =
+                slave->sii_image->sii.syncs[1].physical_start_address;
+            slave->configured_tx_mailbox_size =
+                slave->sii_image->sii.syncs[1].default_length;
         }
-
-        slave->configured_rx_mailbox_offset =
-            slave->sii.syncs[0].physical_start_address;
-        slave->configured_rx_mailbox_size =
-            slave->sii.syncs[0].default_length;
-        slave->configured_tx_mailbox_offset =
-            slave->sii.syncs[1].physical_start_address;
-        slave->configured_tx_mailbox_size =
-            slave->sii.syncs[1].default_length;
+        else {
+            EC_SLAVE_ERR(slave, "Slave has no SyncManager\n");
+        }
     } else { // no mailbox sync manager configurations provided
         ec_sync_t sync;
 
@@ -520,34 +532,34 @@ void ec_fsm_slave_config_enter_mbox_sync
         ec_datagram_zero(datagram);
 
         ec_sync_init(&sync, slave);
-        sync.physical_start_address = slave->sii.std_rx_mailbox_offset;
+        sync.physical_start_address = slave->sii_image->sii.std_rx_mailbox_offset;
         sync.control_register = 0x26;
         sync.enable = 1;
-        ec_sync_page(&sync, 0, slave->sii.std_rx_mailbox_size,
+        ec_sync_page(&sync, 0, slave->sii_image->sii.std_rx_mailbox_size,
                 NULL, // use default sync manager configuration
                 0, // no PDO xfer
                 datagram->data);
         slave->configured_rx_mailbox_offset =
-            slave->sii.std_rx_mailbox_offset;
+            slave->sii_image->sii.std_rx_mailbox_offset;
         slave->configured_rx_mailbox_size =
-            slave->sii.std_rx_mailbox_size;
+            slave->sii_image->sii.std_rx_mailbox_size;
 
         ec_sync_init(&sync, slave);
-        sync.physical_start_address = slave->sii.std_tx_mailbox_offset;
+        sync.physical_start_address = slave->sii_image->sii.std_tx_mailbox_offset;
         sync.control_register = 0x22;
         sync.enable = 1;
-        ec_sync_page(&sync, 1, slave->sii.std_tx_mailbox_size,
+        ec_sync_page(&sync, 1, slave->sii_image->sii.std_tx_mailbox_size,
                 NULL, // use default sync manager configuration
                 0, // no PDO xfer
                 datagram->data + EC_SYNC_PAGE_SIZE);
         slave->configured_tx_mailbox_offset =
-            slave->sii.std_tx_mailbox_offset;
+            slave->sii_image->sii.std_tx_mailbox_offset;
         slave->configured_tx_mailbox_size =
-            slave->sii.std_tx_mailbox_size;
+            slave->sii_image->sii.std_tx_mailbox_size;
     }
 
     // allocate memory for mailbox response data for supported mailbox protocols
-    ec_mbox_prot_data_prealloc(slave, slave->sii.mailbox_protocols, slave->configured_tx_mailbox_size);
+    ec_mbox_prot_data_prealloc(slave, slave->sii_image->sii.mailbox_protocols, slave->configured_tx_mailbox_size);
 
     fsm->take_time = 1;
 
@@ -1104,19 +1116,26 @@ void ec_fsm_slave_config_enter_pdo_sync(
     const ec_sync_t *sync;
     uint16_t size;
 
-    if (slave->sii.mailbox_protocols) {
+    if (!slave->sii_image) {
+        fsm->state = ec_fsm_slave_config_state_error;
+        EC_SLAVE_ERR(slave, "Slave cannot configure PDO SyncManager."
+                " SII data not available.\n");
+        return;
+    }
+
+    if (slave->sii_image->sii.mailbox_protocols) {
         offset = 2; // slave has mailboxes
     } else {
         offset = 0;
     }
 
-    if (slave->sii.sync_count <= offset) {
+    if (slave->sii_image->sii.sync_count <= offset) {
         // no PDO sync managers to configure
         ec_fsm_slave_config_enter_fmmu(fsm);
         return;
     }
 
-    num_pdo_syncs = slave->sii.sync_count - offset;
+    num_pdo_syncs = slave->sii_image->sii.sync_count - offset;
 
     // configure sync managers for process data
     ec_datagram_fpwr(datagram, slave->station_address,
@@ -1128,7 +1147,7 @@ void ec_fsm_slave_config_enter_pdo_sync(
         const ec_sync_config_t *sync_config;
         uint8_t pdo_xfer = 0;
         sync_index = i + offset;
-        sync = &slave->sii.syncs[sync_index];
+        sync = &slave->sii_image->sii.syncs[sync_index];
 
         if (slave->config) {
             const ec_slave_config_t *sc = slave->config;
diff --git a/master/fsm_slave_scan.c b/master/fsm_slave_scan.c
--- a/master/fsm_slave_scan.c
+++ b/master/fsm_slave_scan.c
@@ -53,6 +53,12 @@ void ec_fsm_slave_scan_state_datalink(ec
 #ifdef EC_SII_ASSIGN
 void ec_fsm_slave_scan_state_assign_sii(ec_fsm_slave_scan_t *);
 #endif
+#if EC_REUSE_SII_IMAGE
+void ec_fsm_slave_scan_state_sii_alias(ec_fsm_slave_scan_t *);
+void ec_fsm_slave_scan_state_sii_serial(ec_fsm_slave_scan_t *);
+void ec_fsm_slave_scan_state_sii_vendor(ec_fsm_slave_scan_t *);
+void ec_fsm_slave_scan_state_sii_product(ec_fsm_slave_scan_t *);
+#endif
 void ec_fsm_slave_scan_state_sii_size(ec_fsm_slave_scan_t *);
 void ec_fsm_slave_scan_state_sii_data(ec_fsm_slave_scan_t *);
 void ec_fsm_slave_scan_state_mailbox_cleared(ec_fsm_slave_scan_t *);
@@ -70,6 +76,11 @@ void ec_fsm_slave_scan_enter_datalink(ec
 #ifdef EC_REGALIAS
 void ec_fsm_slave_scan_enter_regalias(ec_fsm_slave_scan_t *);
 #endif
+#if EC_REUSE_SII_IMAGE
+void ec_fsm_slave_scan_enter_sii_alias(ec_fsm_slave_scan_t *);
+#endif
+void ec_fsm_slave_scan_enter_attach_sii(ec_fsm_slave_scan_t *);
+void ec_fsm_slave_scan_enter_sii_size(ec_fsm_slave_scan_t *);
 void ec_fsm_slave_scan_enter_preop(ec_fsm_slave_scan_t *);
 void ec_fsm_slave_scan_enter_clear_mailbox(ec_fsm_slave_scan_t *);
 void ec_fsm_slave_scan_enter_pdos(ec_fsm_slave_scan_t *);
@@ -442,6 +453,112 @@ void ec_fsm_slave_scan_enter_datalink(
     fsm->state = ec_fsm_slave_scan_state_datalink;
 }
 
+#if EC_REUSE_SII_IMAGE
+/*****************************************************************************/
+
+/** Enter slave scan state SII_ALIAS.
+ */
+void ec_fsm_slave_scan_enter_sii_alias(
+        ec_fsm_slave_scan_t *fsm /**< slave state machine */
+        )
+{
+    // Start fetching SII serial number
+    fsm->sii_offset = EC_ALIAS_SII_OFFSET;
+    ec_fsm_sii_read(&fsm->fsm_sii, fsm->slave, fsm->sii_offset,
+            EC_FSM_SII_USE_CONFIGURED_ADDRESS);
+    fsm->state = ec_fsm_slave_scan_state_sii_alias;
+    fsm->state(fsm); // execute state immediately
+}
+#endif
+
+/*****************************************************************************/
+
+/** Enter slave scan state ATTACH_SII.
+ */
+void ec_fsm_slave_scan_enter_attach_sii(
+        ec_fsm_slave_scan_t *fsm /**< slave state machine */
+        )
+{
+    ec_sii_image_t *sii_image;
+    ec_slave_t *slave = fsm->slave;
+
+#if EC_REUSE_SII_IMAGE
+    unsigned int i = 0;
+    unsigned int found = 0;
+
+    if ((slave->effective_alias != 0) || (slave->effective_serial_number != 0)) {
+        list_for_each_entry(sii_image, &slave->master->sii_images, list) {
+            // Check if slave match a stored SII image with alias, serial number,
+            // vendor id and product code.
+            if ((slave->effective_alias != 0) && (slave->effective_alias == sii_image->sii.alias)) {
+                EC_SLAVE_DBG(slave, 1, "Slave can re-use SII image data stored."
+                        " Identified by alias %u.\n", (uint32_t)slave->effective_alias);
+                found = 1;
+                break;
+            }
+            else if ((slave->effective_vendor_id == sii_image->sii.vendor_id) &&
+                     (slave->effective_product_code == sii_image->sii.product_code) &&
+                     (slave->effective_serial_number == sii_image->sii.serial_number)) {
+                EC_SLAVE_DBG(slave, 1, "Slave can re-use SII image data stored."
+                        " Identified by vendor id 0x%08x,"
+                        " product code 0x%08x and serial 0x%08x.\n",
+                        slave->effective_vendor_id,
+                        slave->effective_product_code,
+                        slave->effective_serial_number);
+                found = 1;
+                break;
+            }
+        }
+    }
+    else {
+        EC_SLAVE_DBG(slave, 1, "Slave cannot be uniquely identified."
+                " SII image data cannot be re-used!\n");
+    }
+
+    if (found) {
+        // Update slave references lost during slave initialization
+        slave->effective_vendor_id = sii_image->sii.vendor_id;
+        slave->effective_product_code = sii_image->sii.product_code;
+        slave->effective_serial_number = sii_image->sii.serial_number;
+        slave->sii_image = sii_image;
+        for (i = 0; i < slave->sii_image->sii.sync_count; i++) {
+            slave->sii_image->sii.syncs[i].slave = slave;
+        }
+        // The SII image data is already available and we can enter PREOP
+#ifdef EC_REGALIAS
+        ec_fsm_slave_scan_enter_regalias(fsm);
+#else
+        if (slave->sii_image->sii.mailbox_protocols & EC_MBOX_COE) {
+            ec_fsm_slave_scan_enter_preop(fsm);
+        } else {
+            fsm->state = ec_fsm_slave_scan_state_end;
+        }
+#endif
+    }
+    else
+#endif
+    {
+        EC_MASTER_DBG(slave->master, 1, "Creating slave SII image for %u\n",
+                fsm->slave->ring_position);
+
+        if (!(sii_image = (ec_sii_image_t *) kmalloc(sizeof(ec_sii_image_t),
+                        GFP_KERNEL))) {
+            fsm->state = ec_fsm_slave_scan_state_error;
+            EC_MASTER_ERR(fsm->slave->master, "Failed to allocate memory"
+                    " for slave SII image.\n");
+            return;
+        }
+        // Initialize SII image data
+        ec_slave_sii_image_init(sii_image);
+        // Attach SII image to the slave
+        slave->sii_image = sii_image;
+        // Store the SII image for later re-use
+        list_add_tail(&sii_image->list, &slave->master->sii_images);
+
+        ec_fsm_slave_scan_enter_sii_size(fsm);
+    }
+}
+
 /*****************************************************************************/
 
 /** Enter slave scan state SII_SIZE.
@@ -518,8 +635,10 @@ void ec_fsm_slave_scan_state_datalink(
 
 #ifdef EC_SII_ASSIGN
     ec_fsm_slave_scan_enter_assign_sii(fsm);
+#elif EC_REUSE_SII_IMAGE
+    ec_fsm_slave_scan_enter_sii_alias(fsm);
 #else
-    ec_fsm_slave_scan_enter_sii_size(fsm);
+    ec_fsm_slave_scan_enter_attach_sii(fsm);
 #endif
 }
 
@@ -556,11 +675,149 @@ void ec_fsm_slave_scan_state_assign_sii(
     }
 
 continue_with_sii_size:
-    ec_fsm_slave_scan_enter_sii_size(fsm);
+#if EC_REUSE_SII_IMAGE
+    ec_fsm_slave_scan_enter_sii_alias(fsm);
+#else
+    ec_fsm_slave_scan_enter_attach_sii(fsm);
+#endif
 }
 
 #endif
 
+#if EC_REUSE_SII_IMAGE
+/*****************************************************************************/
+
+/**
+   Slave scan state: SII ALIAS.
+*/
+
+void ec_fsm_slave_scan_state_sii_alias(
+        ec_fsm_slave_scan_t *fsm /**< slave state machine */
+        )
+{
+    ec_slave_t *slave = fsm->slave;
+
+    if (ec_fsm_sii_exec(&fsm->fsm_sii))
+        return;
+
+    if (!ec_fsm_sii_success(&fsm->fsm_sii)) {
+        fsm->slave->error_flag = 1;
+        fsm->state = ec_fsm_slave_scan_state_error;
+        EC_SLAVE_ERR(slave, "Failed to determine SII alias\n");
+    }
+
+    slave->effective_alias = EC_READ_U32(fsm->fsm_sii.value);
+
+    EC_SLAVE_DBG(slave, 1, "Alias: %u\n", (uint32_t)slave->effective_alias);
+
+    if (slave->effective_alias == 0) {
+        // Start fetching SII serial number
+        fsm->sii_offset = EC_SERIAL_SII_OFFSET;
+        ec_fsm_sii_read(&fsm->fsm_sii, fsm->slave, fsm->sii_offset,
+                EC_FSM_SII_USE_CONFIGURED_ADDRESS);
+        fsm->state = ec_fsm_slave_scan_state_sii_serial;
+        fsm->state(fsm); // execute state immediately
+    }
+    else {
+        ec_fsm_slave_scan_enter_attach_sii(fsm);
+    }
+}
+
+/*****************************************************************************/
+
+/**
+   Slave scan state: SII SERIAL.
+*/
+
+void ec_fsm_slave_scan_state_sii_serial(
+        ec_fsm_slave_scan_t *fsm /**< slave state machine */
+        )
+{
+    ec_slave_t *slave = fsm->slave;
+
+    if (ec_fsm_sii_exec(&fsm->fsm_sii))
+        return;
+
+    if (!ec_fsm_sii_success(&fsm->fsm_sii)) {
+        fsm->slave->error_flag = 1;
+        fsm->state = ec_fsm_slave_scan_state_error;
+        EC_SLAVE_ERR(slave, "Failed to determine SII serial number\n");
+    }
+
+    slave->effective_serial_number = EC_READ_U32(fsm->fsm_sii.value);
+
+    EC_SLAVE_DBG(slave, 1, "Serial Number: 0x%08x\n", slave->effective_serial_number);
+
+    // Start fetching SII vendor ID
+    fsm->sii_offset = EC_VENDOR_SII_OFFSET;
+    ec_fsm_sii_read(&fsm->fsm_sii, fsm->slave, fsm->sii_offset,
+            EC_FSM_SII_USE_CONFIGURED_ADDRESS);
+    fsm->state = ec_fsm_slave_scan_state_sii_vendor;
+    fsm->state(fsm); // execute state immediately
+}
+
+/*****************************************************************************/
+
+/**
+   Slave scan state: SII VENDOR.
+*/
+
+void ec_fsm_slave_scan_state_sii_vendor(
+        ec_fsm_slave_scan_t *fsm /**< slave state machine */
+        )
+{
+    ec_slave_t *slave = fsm->slave;
+
+    if (ec_fsm_sii_exec(&fsm->fsm_sii))
+        return;
+
+    if (!ec_fsm_sii_success(&fsm->fsm_sii)) {
+        fsm->slave->error_flag = 1;
+        fsm->state = ec_fsm_slave_scan_state_error;
+        EC_SLAVE_ERR(slave, "Failed to determine SII vendor ID\n");
+    }
+
+    slave->effective_vendor_id = EC_READ_U32(fsm->fsm_sii.value);
+
+    EC_SLAVE_DBG(slave, 1, "Vendor ID: 0x%08x\n", slave->effective_vendor_id);
+
+    // Start fetching SII product code
+    fsm->sii_offset = EC_PRODUCT_SII_OFFSET;
+    ec_fsm_sii_read(&fsm->fsm_sii, fsm->slave, fsm->sii_offset,
+            EC_FSM_SII_USE_CONFIGURED_ADDRESS);
+    fsm->state = ec_fsm_slave_scan_state_sii_product;
+    fsm->state(fsm); // execute state immediately
+}
+
+/*****************************************************************************/
+
+/**
+   Slave scan state: SII PRODUCT.
+*/
+
+void ec_fsm_slave_scan_state_sii_product(
+        ec_fsm_slave_scan_t *fsm /**< slave state machine */
+        )
+{
+    ec_slave_t *slave = fsm->slave;
+
+    if (ec_fsm_sii_exec(&fsm->fsm_sii))
+        return;
+
+    if (!ec_fsm_sii_success(&fsm->fsm_sii)) {
+        fsm->slave->error_flag = 1;
+        fsm->state = ec_fsm_slave_scan_state_error;
+        EC_SLAVE_ERR(slave, "Failed to determine SII product code\n");
+    }
+
+    slave->effective_product_code = EC_READ_U32(fsm->fsm_sii.value);
+
+    EC_SLAVE_DBG(slave, 1, "Product code: 0x%08x\n", slave->effective_product_code);
+
+    ec_fsm_slave_scan_enter_attach_sii(fsm);
+}
+#endif
+
 /*****************************************************************************/
 
 /**
@@ -577,13 +834,20 @@ void ec_fsm_slave_scan_state_sii_size(
     if (ec_fsm_sii_exec(&fsm->fsm_sii))
         return;
 
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave has no SII image attached!\n");
+        slave->error_flag = 1;
+        fsm->state = ec_fsm_slave_scan_state_error;
+        return;
+    }
+
     if (!ec_fsm_sii_success(&fsm->fsm_sii)) {
         fsm->slave->error_flag = 1;
         fsm->state = ec_fsm_slave_scan_state_error;
         EC_SLAVE_ERR(slave, "Failed to determine SII content size:"
                 " Reading word offset 0x%04x failed. Assuming %u words.\n",
                 fsm->sii_offset, EC_FIRST_SII_CATEGORY_OFFSET);
-        slave->sii_nwords = EC_FIRST_SII_CATEGORY_OFFSET;
+        slave->sii_image->nwords = EC_FIRST_SII_CATEGORY_OFFSET;
         goto alloc_sii;
     }
 
@@ -596,7 +860,7 @@ void ec_fsm_slave_scan_state_sii_size(
             EC_SLAVE_WARN(slave, "SII size exceeds %u words"
                     " (0xffff limiter missing?).\n", EC_MAX_SII_SIZE);
             // cut off category data...
-            slave->sii_nwords = EC_FIRST_SII_CATEGORY_OFFSET;
+            slave->sii_image->nwords = EC_FIRST_SII_CATEGORY_OFFSET;
             goto alloc_sii;
         }
         fsm->sii_offset = next_offset;
@@ -606,19 +870,19 @@ void ec_fsm_slave_scan_state_sii_size(
         return;
     }
 
-    slave->sii_nwords = fsm->sii_offset + 1;
+    slave->sii_image->nwords = fsm->sii_offset + 1;
 
 alloc_sii:
-    if (slave->sii_words) {
+    if (slave->sii_image->words) {
         EC_SLAVE_WARN(slave, "Freeing old SII data...\n");
-        kfree(slave->sii_words);
+        kfree(slave->sii_image->words);
     }
 
-    if (!(slave->sii_words =
-                (uint16_t *) kmalloc(slave->sii_nwords * 2, GFP_KERNEL))) {
+    if (!(slave->sii_image->words =
+                (uint16_t *) kmalloc(slave->sii_image->nwords * 2, GFP_KERNEL))) {
         EC_SLAVE_ERR(slave, "Failed to allocate %zu words of SII data.\n",
-               slave->sii_nwords);
-        slave->sii_nwords = 0;
+               slave->sii_image->nwords);
+        slave->sii_image->nwords = 0;
         slave->error_flag = 1;
         fsm->state = ec_fsm_slave_scan_state_error;
         return;
@@ -653,15 +917,22 @@ void ec_fsm_slave_scan_state_sii_data(ec
         return;
     }
 
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave has no SII image attached!\n");
+        slave->error_flag = 1;
+        fsm->state = ec_fsm_slave_scan_state_error;
+        return;
+    }
+
     // 2 words fetched
 
-    if (fsm->sii_offset + 2 <= slave->sii_nwords) { // 2 words fit
-        memcpy(slave->sii_words + fsm->sii_offset, fsm->fsm_sii.value, 4);
+    if (fsm->sii_offset + 2 <= slave->sii_image->nwords) { // 2 words fit
+        memcpy(slave->sii_image->words + fsm->sii_offset, fsm->fsm_sii.value, 4);
     } else { // copy the last word
-        memcpy(slave->sii_words + fsm->sii_offset, fsm->fsm_sii.value, 2);
+        memcpy(slave->sii_image->words + fsm->sii_offset, fsm->fsm_sii.value, 2);
     }
 
-    if (fsm->sii_offset + 2 < slave->sii_nwords) {
+    if (fsm->sii_offset + 2 < slave->sii_image->nwords) {
         // fetch the next 2 words
         fsm->sii_offset += 2;
         ec_fsm_sii_read(&fsm->fsm_sii, slave, fsm->sii_offset,
@@ -674,71 +945,77 @@ void ec_fsm_slave_scan_state_sii_data(ec
 
     ec_slave_clear_sync_managers(slave);
 
-    slave->sii.alias =
-        EC_READ_U16(slave->sii_words + 0x0004);
-    slave->effective_alias = slave->sii.alias;
-    slave->sii.vendor_id =
-        EC_READ_U32(slave->sii_words + 0x0008);
-    slave->sii.product_code =
-        EC_READ_U32(slave->sii_words + 0x000A);
-    slave->sii.revision_number =
-        EC_READ_U32(slave->sii_words + 0x000C);
-    slave->sii.serial_number =
-        EC_READ_U32(slave->sii_words + 0x000E);
-    slave->sii.boot_rx_mailbox_offset =
-        EC_READ_U16(slave->sii_words + 0x0014);
-    slave->sii.boot_rx_mailbox_size =
-        EC_READ_U16(slave->sii_words + 0x0015);
-    slave->sii.boot_tx_mailbox_offset =
-        EC_READ_U16(slave->sii_words + 0x0016);
-    slave->sii.boot_tx_mailbox_size =
-        EC_READ_U16(slave->sii_words + 0x0017);
-    slave->sii.std_rx_mailbox_offset =
-        EC_READ_U16(slave->sii_words + 0x0018);
-    slave->sii.std_rx_mailbox_size =
-        EC_READ_U16(slave->sii_words + 0x0019);
-    slave->sii.std_tx_mailbox_offset =
-        EC_READ_U16(slave->sii_words + 0x001A);
-    slave->sii.std_tx_mailbox_size =
-        EC_READ_U16(slave->sii_words + 0x001B);
-    slave->sii.mailbox_protocols =
-        EC_READ_U16(slave->sii_words + 0x001C);
+    slave->sii_image->sii.alias =
+        EC_READ_U16(slave->sii_image->words + 0x0004);
+    slave->effective_alias = slave->sii_image->sii.alias;
+    slave->sii_image->sii.vendor_id =
+        EC_READ_U32(slave->sii_image->words + 0x0008);
+    slave->sii_image->sii.product_code =
+        EC_READ_U32(slave->sii_image->words + 0x000A);
+    slave->sii_image->sii.revision_number =
+        EC_READ_U32(slave->sii_image->words + 0x000C);
+    slave->sii_image->sii.serial_number =
+        EC_READ_U32(slave->sii_image->words + 0x000E);
+    slave->sii_image->sii.boot_rx_mailbox_offset =
+        EC_READ_U16(slave->sii_image->words + 0x0014);
+    slave->sii_image->sii.boot_rx_mailbox_size =
+        EC_READ_U16(slave->sii_image->words + 0x0015);
+    slave->sii_image->sii.boot_tx_mailbox_offset =
+        EC_READ_U16(slave->sii_image->words + 0x0016);
+    slave->sii_image->sii.boot_tx_mailbox_size =
+        EC_READ_U16(slave->sii_image->words + 0x0017);
+    slave->sii_image->sii.std_rx_mailbox_offset =
+        EC_READ_U16(slave->sii_image->words + 0x0018);
+    slave->sii_image->sii.std_rx_mailbox_size =
+        EC_READ_U16(slave->sii_image->words + 0x0019);
+    slave->sii_image->sii.std_tx_mailbox_offset =
+        EC_READ_U16(slave->sii_image->words + 0x001A);
+    slave->sii_image->sii.std_tx_mailbox_size =
+        EC_READ_U16(slave->sii_image->words + 0x001B);
+    slave->sii_image->sii.mailbox_protocols =
+        EC_READ_U16(slave->sii_image->words + 0x001C);
+
+#if EC_REUSE_SII_IMAGE
+    slave->effective_vendor_id = slave->sii_image->sii.vendor_id;
+    slave->effective_product_code = slave->sii_image->sii.product_code;
+    slave->effective_serial_number = slave->sii_image->sii.serial_number;
+#endif
 
     // clear mailbox settings if invalid values due to invalid sii file
-    if ((slave->sii.boot_rx_mailbox_offset == 0xFFFF) ||
-        (slave->sii.boot_tx_mailbox_offset == 0xFFFF) ||
-        (slave->sii.std_rx_mailbox_offset  == 0xFFFF) ||
-        (slave->sii.std_tx_mailbox_offset  == 0xFFFF)) {
-        slave->sii.boot_rx_mailbox_offset = 0;
-        slave->sii.boot_tx_mailbox_offset = 0;
-        slave->sii.boot_rx_mailbox_size = 0;
-        slave->sii.boot_tx_mailbox_size = 0;
-        slave->sii.std_rx_mailbox_offset = 0;
-        slave->sii.std_tx_mailbox_offset = 0;
-        slave->sii.std_rx_mailbox_size = 0;
-        slave->sii.std_tx_mailbox_size = 0;
-        slave->sii.mailbox_protocols = 0;
+    if ((slave->sii_image->sii.boot_rx_mailbox_offset == 0xFFFF) ||
+        (slave->sii_image->sii.boot_tx_mailbox_offset == 0xFFFF) ||
+        (slave->sii_image->sii.std_rx_mailbox_offset  == 0xFFFF) ||
+        (slave->sii_image->sii.std_tx_mailbox_offset  == 0xFFFF)) {
+        slave->sii_image->sii.boot_rx_mailbox_offset = 0;
+        slave->sii_image->sii.boot_tx_mailbox_offset = 0;
+        slave->sii_image->sii.boot_rx_mailbox_size = 0;
+        slave->sii_image->sii.boot_tx_mailbox_size = 0;
+        slave->sii_image->sii.std_rx_mailbox_offset = 0;
+        slave->sii_image->sii.std_tx_mailbox_offset = 0;
+        slave->sii_image->sii.std_rx_mailbox_size = 0;
+        slave->sii_image->sii.std_tx_mailbox_size = 0;
+        slave->sii_image->sii.mailbox_protocols = 0;
         EC_SLAVE_ERR(slave, "Unexpected mailbox offset in SII data.\n");
     }
 
-    if (slave->sii_nwords == EC_FIRST_SII_CATEGORY_OFFSET) {
+    if (slave->sii_image->nwords == EC_FIRST_SII_CATEGORY_OFFSET) {
         // sii does not contain category data
         fsm->state = ec_fsm_slave_scan_state_end;
         return;
     }
 
-    if (slave->sii_nwords < EC_FIRST_SII_CATEGORY_OFFSET + 1) {
+    if (slave->sii_image->nwords < EC_FIRST_SII_CATEGORY_OFFSET + 1) {
         EC_SLAVE_ERR(slave, "Unexpected end of SII data:"
                 " First category header missing.\n");
         goto end;
     }
 
     // evaluate category data
-    cat_word = slave->sii_words + EC_FIRST_SII_CATEGORY_OFFSET;
+    cat_word = slave->sii_image->words + EC_FIRST_SII_CATEGORY_OFFSET;
     while (EC_READ_U16(cat_word) != 0xFFFF) {
 
         // type and size words must fit
-        if (cat_word + 2 - slave->sii_words > slave->sii_nwords) {
+        if (cat_word + 2 - slave->sii_image->words > slave->sii_image->nwords) {
             EC_SLAVE_ERR(slave, "Unexpected end of SII data:"
                     " Category header incomplete.\n");
             goto end;
@@ -748,7 +1025,7 @@ void ec_fsm_slave_scan_state_sii_data(ec
         cat_size = EC_READ_U16(cat_word + 1);
         cat_word += 2;
 
-        if (cat_word + cat_size - slave->sii_words > slave->sii_nwords) {
+        if (cat_word + cat_size - slave->sii_image->words > slave->sii_image->nwords) {
             EC_SLAVE_WARN(slave, "Unexpected end of SII data:"
                     " Category data incomplete.\n");
             goto end;
@@ -788,7 +1065,7 @@ void ec_fsm_slave_scan_state_sii_data(ec
         }
 
         cat_word += cat_size;
-        if (cat_word - slave->sii_words >= slave->sii_nwords) {
+        if (cat_word - slave->sii_image->words >= slave->sii_image->nwords) {
             EC_SLAVE_WARN(slave, "Unexpected end of SII data:"
                     " Next category header missing.\n");
             goto end;
@@ -798,7 +1075,7 @@ void ec_fsm_slave_scan_state_sii_data(ec
 #ifdef EC_REGALIAS
     ec_fsm_slave_scan_enter_regalias(fsm);
 #else
-    if (slave->sii.mailbox_protocols & EC_MBOX_COE) {
+    if (slave->sii_image->sii.mailbox_protocols & EC_MBOX_COE) {
         ec_fsm_slave_scan_enter_preop(fsm);
     } else {
         fsm->state = ec_fsm_slave_scan_state_end;
@@ -862,7 +1139,14 @@ void ec_fsm_slave_scan_state_regalias(
                 slave->effective_alias);
     }
 
-    if (slave->sii.mailbox_protocols & EC_MBOX_COE) {
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave has no SII image attached!\n");
+        slave->error_flag = 1;
+        fsm->state = ec_fsm_slave_scan_state_error;
+        return;
+    }
+
+    if (slave->sii_image->sii.mailbox_protocols & EC_MBOX_COE) {
         ec_fsm_slave_scan_enter_preop(fsm);
     } else {
         fsm->state = ec_fsm_slave_scan_state_end;
@@ -972,8 +1256,15 @@ void ec_fsm_slave_scan_state_sync(
             slave->configured_tx_mailbox_offset,
             slave->configured_tx_mailbox_size);
 
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave has no SII image attached!\n");
+        slave->error_flag = 1;
+        fsm->state = ec_fsm_slave_scan_state_error;
+        return;
+    }
+
     // allocate memory for mailbox response data for supported mailbox protocols
-    ec_mbox_prot_data_prealloc(slave, slave->sii.mailbox_protocols, slave->configured_tx_mailbox_size);
+    ec_mbox_prot_data_prealloc(slave, slave->sii_image->sii.mailbox_protocols, slave->configured_tx_mailbox_size);
 
     ec_fsm_slave_scan_enter_clear_mailbox(fsm);
 }
@@ -1008,6 +1299,11 @@ void ec_fsm_slave_scan_state_mailbox_cle
     ec_slave_t *slave = fsm->slave;
     ec_datagram_t *datagram = fsm->datagram;
 
+#if EC_REUSE_SII_IMAGE
+    unsigned int i = 0;
+    unsigned int fetch_pdos = 1;
+#endif
+
     if (fsm->datagram->state == EC_DATAGRAM_TIMED_OUT && fsm->retries--) {
         ec_slave_mbox_prepare_fetch(fsm->slave, datagram);
         return;
@@ -1020,7 +1316,31 @@ void ec_fsm_slave_scan_state_mailbox_cle
 
     slave->valid_mbox_data = 1;
 
-    ec_fsm_slave_scan_enter_pdos(fsm);
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave has no SII image attached!\n");
+        slave->error_flag = 1;
+        fsm->state = ec_fsm_slave_scan_state_error;
+        return;
+    }
+
+#if EC_REUSE_SII_IMAGE
+    if ((slave->effective_alias != 0) || (slave->effective_serial_number != 0)) {
+        // SII data has been stored
+        for (i = 0; i < slave->sii_image->sii.sync_count; i++) {
+            if (!list_empty(&slave->sii_image->sii.syncs[i].pdos.list)) {
+                fetch_pdos = 0; // PDOs already fetched
+                break;
+            }
+        }
+    }
+    if (!fetch_pdos) {
+        fsm->state = ec_fsm_slave_scan_state_end;
+    }
+    else
+#endif
+    {
+        ec_fsm_slave_scan_enter_pdos(fsm);
+    }
 }
 
 /*****************************************************************************/
diff --git a/master/fsm_soe.c b/master/fsm_soe.c
--- a/master/fsm_soe.c
+++ b/master/fsm_soe.c
@@ -264,7 +264,15 @@ void ec_fsm_soe_read_start(
     EC_SLAVE_DBG(slave, 1, "Reading IDN 0x%04X of drive %u.\n", request->idn,
             request->drive_no);
 
-    if (!(slave->sii.mailbox_protocols & EC_MBOX_SOE)) {
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave cannot process SoE read request."
+                " SII data not available.\n");
+        fsm->state = ec_fsm_soe_error;
+        ec_fsm_soe_print_error(fsm);
+        return;
+    }
+
+    if (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_SOE)) {
         EC_SLAVE_ERR(slave, "Slave does not support SoE!\n");
         fsm->state = ec_fsm_soe_error;
         ec_fsm_soe_print_error(fsm);
@@ -640,7 +648,15 @@ void ec_fsm_soe_write_start(
     EC_SLAVE_DBG(slave, 1, "Writing IDN 0x%04X of drive %u (%zu byte).\n",
             req->idn, req->drive_no, req->data_size);
 
-    if (!(slave->sii.mailbox_protocols & EC_MBOX_SOE)) {
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave cannot process SoE write request."
+                " SII data not available.\n");
+        fsm->state = ec_fsm_soe_error;
+        ec_fsm_soe_print_error(fsm);
+        return;
+    }
+
+    if (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_SOE)) {
         EC_SLAVE_ERR(slave, "Slave does not support SoE!\n");
         fsm->state = ec_fsm_soe_error;
         ec_fsm_soe_print_error(fsm);
diff --git a/master/globals.h b/master/globals.h
--- a/master/globals.h
+++ b/master/globals.h
@@ -65,6 +65,10 @@
 /** If set, skip fetching SDO dictionary during slave scan. */
 #define EC_SKIP_SDO_DICT 1
 
+/** If set, re-use the stored SII image to improve slave re-scan
+ *  performance in operational state. */
+#define EC_REUSE_SII_IMAGE 1
+
 /** Minimum size of a buffer used with ec_state_string(). */
 #define EC_STATE_STRING_SIZE 32
 
@@ -106,6 +110,18 @@
 /** Word offset of first SII category. */
 #define EC_FIRST_SII_CATEGORY_OFFSET 0x40
 
+/** Word offset of SII alias. */
+#define EC_ALIAS_SII_OFFSET 0x04
+
+/** Word offset of SII vendor ID. */
+#define EC_VENDOR_SII_OFFSET 0x08
+
+/** Word offset of SII product number. */
+#define EC_PRODUCT_SII_OFFSET 0x0A
+
+/** Word offset of SII serial number. */
+#define EC_SERIAL_SII_OFFSET 0x0E
+
 /** Size of a sync manager configuration page. */
 #define EC_SYNC_PAGE_SIZE 8
 
diff --git a/master/ioctl.c b/master/ioctl.c
--- a/master/ioctl.c
+++ b/master/ioctl.c
@@ -230,24 +230,63 @@ static ATTRIBUTES int ec_ioctl_slave(
     }
 
     data.device_index = slave->device_index;
-    data.vendor_id = slave->sii.vendor_id;
-    data.product_code = slave->sii.product_code;
-    data.revision_number = slave->sii.revision_number;
-    data.serial_number = slave->sii.serial_number;
     data.alias = slave->effective_alias;
-    data.boot_rx_mailbox_offset = slave->sii.boot_rx_mailbox_offset;
-    data.boot_rx_mailbox_size = slave->sii.boot_rx_mailbox_size;
-    data.boot_tx_mailbox_offset = slave->sii.boot_tx_mailbox_offset;
-    data.boot_tx_mailbox_size = slave->sii.boot_tx_mailbox_size;
-    data.std_rx_mailbox_offset = slave->sii.std_rx_mailbox_offset;
-    data.std_rx_mailbox_size = slave->sii.std_rx_mailbox_size;
-    data.std_tx_mailbox_offset = slave->sii.std_tx_mailbox_offset;
-    data.std_tx_mailbox_size = slave->sii.std_tx_mailbox_size;
-    data.mailbox_protocols = slave->sii.mailbox_protocols;
-    data.has_general_category = slave->sii.has_general;
-    data.coe_details = slave->sii.coe_details;
-    data.general_flags = slave->sii.general_flags;
-    data.current_on_ebus = slave->sii.current_on_ebus;
+    if (slave->sii_image) {
+        data.vendor_id = slave->sii_image->sii.vendor_id;
+        data.product_code = slave->sii_image->sii.product_code;
+        data.revision_number = slave->sii_image->sii.revision_number;
+        data.serial_number = slave->sii_image->sii.serial_number;
+        data.boot_rx_mailbox_offset = slave->sii_image->sii.boot_rx_mailbox_offset;
+        data.boot_rx_mailbox_size = slave->sii_image->sii.boot_rx_mailbox_size;
+        data.boot_tx_mailbox_offset = slave->sii_image->sii.boot_tx_mailbox_offset;
+        data.boot_tx_mailbox_size = slave->sii_image->sii.boot_tx_mailbox_size;
+        data.std_rx_mailbox_offset = slave->sii_image->sii.std_rx_mailbox_offset;
+        data.std_rx_mailbox_size = slave->sii_image->sii.std_rx_mailbox_size;
+        data.std_tx_mailbox_offset = slave->sii_image->sii.std_tx_mailbox_offset;
+        data.std_tx_mailbox_size = slave->sii_image->sii.std_tx_mailbox_size;
+        data.mailbox_protocols = slave->sii_image->sii.mailbox_protocols;
+        data.has_general_category = slave->sii_image->sii.has_general;
+        data.coe_details = slave->sii_image->sii.coe_details;
+        data.general_flags = slave->sii_image->sii.general_flags;
+        data.current_on_ebus = slave->sii_image->sii.current_on_ebus;
+        data.sync_count = slave->sii_image->sii.sync_count;
+        data.sii_nwords = slave->sii_image->nwords;
+        ec_ioctl_strcpy(data.group, slave->sii_image->sii.group);
+        ec_ioctl_strcpy(data.image, slave->sii_image->sii.image);
+        ec_ioctl_strcpy(data.order, slave->sii_image->sii.order);
+        ec_ioctl_strcpy(data.name, slave->sii_image->sii.name);
+    }
+    else {
+        data.vendor_id = 0x00000000;
+        data.product_code = 0x00000000;
+        data.revision_number = 0x00000000;
+        data.serial_number = 0x00000000;
+        data.boot_rx_mailbox_offset = 0x0000;
+        data.boot_rx_mailbox_size = 0x0000;
+        data.boot_tx_mailbox_offset = 0x0000;
+        data.boot_tx_mailbox_size = 0x0000;
+        data.std_rx_mailbox_offset = 0x0000;
+        data.std_rx_mailbox_size = 0x0000;
+        data.std_tx_mailbox_offset = 0x0000;
+        data.std_tx_mailbox_size = 0x0000;
+        data.mailbox_protocols = 0;
+        data.has_general_category = 0;
+        data.coe_details.enable_pdo_assign = 0;
+        data.coe_details.enable_pdo_configuration = 0;
+        data.coe_details.enable_sdo = 0;
+        data.coe_details.enable_sdo_complete_access = 0;
+        data.coe_details.enable_sdo_info = 0;
+        data.coe_details.enable_upload_at_startup = 0;
+        data.general_flags.enable_not_lrw = 0;
+        data.general_flags.enable_safeop = 0;
+        data.sync_count = 0;
+        data.sii_nwords = 0;
+        ec_ioctl_strcpy(data.group, "");
+        ec_ioctl_strcpy(data.image, "");
+        ec_ioctl_strcpy(data.order, "");
+        ec_ioctl_strcpy(data.name, "");
+    }
+
     for (i = 0; i < EC_MAX_PORTS; i++) {
         data.ports[i].desc = slave->ports[i].desc;
         data.ports[i].link.link_up = slave->ports[i].link.link_up;
@@ -270,14 +309,7 @@ static ATTRIBUTES int ec_ioctl_slave(
     data.transmission_delay = slave->transmission_delay;
     data.al_state = slave->current_state;
     data.error_flag = slave->error_flag;
-
-    data.sync_count = slave->sii.sync_count;
     data.sdo_count = ec_slave_sdo_count(slave);
-    data.sii_nwords = slave->sii_nwords;
-    ec_ioctl_strcpy(data.group, slave->sii.group);
-    ec_ioctl_strcpy(data.image, slave->sii.image);
-    ec_ioctl_strcpy(data.order, slave->sii.order);
-    ec_ioctl_strcpy(data.name, slave->sii.name);
 
     ec_lock_up(&master->master_sem);
 
@@ -317,21 +349,32 @@ static ATTRIBUTES int ec_ioctl_slave_syn
         return -EINVAL;
     }
 
-    if (data.sync_index >= slave->sii.sync_count) {
-        ec_lock_up(&master->master_sem);
-        EC_SLAVE_ERR(slave, "Sync manager %u does not exist!\n",
+    if (slave->sii_image) {
+        if (data.sync_index >= slave->sii_image->sii.sync_count) {
+            ec_lock_up(&master->master_sem);
+            EC_SLAVE_ERR(slave, "Sync manager %u does not exist!\n",
+                    data.sync_index);
+            return -EINVAL;
+        }
+
+        sync = &slave->sii_image->sii.syncs[data.sync_index];
+
+        data.physical_start_address = sync->physical_start_address;
+        data.default_size = sync->default_length;
+        data.control_register = sync->control_register;
+        data.enable = sync->enable;
+        data.pdo_count = ec_pdo_list_count(&sync->pdos);
+    }
+    else {
+        EC_SLAVE_INFO(slave, "No access to SII data for SyncManager %u!\n",
                 data.sync_index);
-        return -EINVAL;
-    }
-
-    sync = &slave->sii.syncs[data.sync_index];
-
-    data.physical_start_address = sync->physical_start_address;
-    data.default_size = sync->default_length;
-    data.control_register = sync->control_register;
-    data.enable = sync->enable;
-    data.pdo_count = ec_pdo_list_count(&sync->pdos);
-
+
+        data.physical_start_address = 0;
+        data.default_size = 0;
+        data.control_register = 0;
+        data.enable = 0;
+        data.pdo_count = 0;
+    }
     ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
@@ -371,26 +414,35 @@ static ATTRIBUTES int ec_ioctl_slave_syn
         return -EINVAL;
     }
 
-    if (data.sync_index >= slave->sii.sync_count) {
-        ec_lock_up(&master->master_sem);
-        EC_SLAVE_ERR(slave, "Sync manager %u does not exist!\n",
+    if (slave->sii_image) {
+        if (data.sync_index >= slave->sii_image->sii.sync_count) {
+            ec_lock_up(&master->master_sem);
+            EC_SLAVE_ERR(slave, "Sync manager %u does not exist!\n",
+                    data.sync_index);
+            return -EINVAL;
+        }
+
+        sync = &slave->sii_image->sii.syncs[data.sync_index];
+        if (!(pdo = ec_pdo_list_find_pdo_by_pos_const(
+                        &sync->pdos, data.pdo_pos))) {
+            ec_lock_up(&master->master_sem);
+            EC_SLAVE_ERR(slave, "Sync manager %u does not contain a PDO with "
+                    "position %u!\n", data.sync_index, data.pdo_pos);
+            return -EINVAL;
+        }
+
+        data.index = pdo->index;
+        data.entry_count = ec_pdo_entry_count(pdo);
+        ec_ioctl_strcpy(data.name, pdo->name);
+    }
+    else {
+        EC_SLAVE_INFO(slave, "No access to SII data for SyncManager %u!\n",
                 data.sync_index);
-        return -EINVAL;
-    }
-
-    sync = &slave->sii.syncs[data.sync_index];
-    if (!(pdo = ec_pdo_list_find_pdo_by_pos_const(
-                    &sync->pdos, data.pdo_pos))) {
-        ec_lock_up(&master->master_sem);
-        EC_SLAVE_ERR(slave, "Sync manager %u does not contain a PDO with "
-                "position %u!\n", data.sync_index, data.pdo_pos);
-        return -EINVAL;
-    }
-
-    data.index = pdo->index;
-    data.entry_count = ec_pdo_entry_count(pdo);
-    ec_ioctl_strcpy(data.name, pdo->name);
-
+
+        data.index = 0;
+        data.entry_count = 0;
+        ec_ioctl_strcpy(data.name, "");
+    }
     ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
@@ -431,35 +483,45 @@ static ATTRIBUTES int ec_ioctl_slave_syn
         return -EINVAL;
     }
 
-    if (data.sync_index >= slave->sii.sync_count) {
-        ec_lock_up(&master->master_sem);
-        EC_SLAVE_ERR(slave, "Sync manager %u does not exist!\n",
+    if (slave->sii_image) {
+        if (data.sync_index >= slave->sii_image->sii.sync_count) {
+            ec_lock_up(&master->master_sem);
+            EC_SLAVE_ERR(slave, "Sync manager %u does not exist!\n",
+                    data.sync_index);
+            return -EINVAL;
+        }
+
+        sync = &slave->sii_image->sii.syncs[data.sync_index];
+        if (!(pdo = ec_pdo_list_find_pdo_by_pos_const(
+                        &sync->pdos, data.pdo_pos))) {
+            ec_lock_up(&master->master_sem);
+            EC_SLAVE_ERR(slave, "Sync manager %u does not contain a PDO with "
+                    "position %u!\n", data.sync_index, data.pdo_pos);
+            return -EINVAL;
+        }
+
+        if (!(entry = ec_pdo_find_entry_by_pos_const(
+                        pdo, data.entry_pos))) {
+            ec_lock_up(&master->master_sem);
+            EC_SLAVE_ERR(slave, "PDO 0x%04X does not contain an entry with "
+                    "position %u!\n", data.pdo_pos, data.entry_pos);
+            return -EINVAL;
+        }
+
+        data.index = entry->index;
+        data.subindex = entry->subindex;
+        data.bit_length = entry->bit_length;
+        ec_ioctl_strcpy(data.name, entry->name);
+    }
+    else {
+        EC_SLAVE_INFO(slave, "No access to SII data for Sync manager %u!\n",
                 data.sync_index);
-        return -EINVAL;
-    }
-
-    sync = &slave->sii.syncs[data.sync_index];
-    if (!(pdo = ec_pdo_list_find_pdo_by_pos_const(
-                    &sync->pdos, data.pdo_pos))) {
-        ec_lock_up(&master->master_sem);
-        EC_SLAVE_ERR(slave, "Sync manager %u does not contain a PDO with "
-                "position %u!\n", data.sync_index, data.pdo_pos);
-        return -EINVAL;
-    }
-
-    if (!(entry = ec_pdo_find_entry_by_pos_const(
-                    pdo, data.entry_pos))) {
-        ec_lock_up(&master->master_sem);
-        EC_SLAVE_ERR(slave, "PDO 0x%04X does not contain an entry with "
-                "position %u!\n", data.pdo_pos, data.entry_pos);
-        return -EINVAL;
-    }
-
-    data.index = entry->index;
-    data.subindex = entry->subindex;
-    data.bit_length = entry->bit_length;
-    ec_ioctl_strcpy(data.name, entry->name);
-
+
+        data.index = 0;
+        data.subindex = 0;
+        data.bit_length = 0;
+        ec_ioctl_strcpy(data.name, "");
+    }
     ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
@@ -927,16 +989,21 @@ static ATTRIBUTES int ec_ioctl_slave_sii
         return -EINVAL;
     }
 
+    if (!slave->sii_image) {
+        EC_SLAVE_INFO(slave, "No access to SII data. Try again!\n");
+        return -EAGAIN;
+    }
+
     if (!data.nwords
-            || data.offset + data.nwords > slave->sii_nwords) {
+            || data.offset + data.nwords > slave->sii_image->nwords) {
         ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "Invalid SII read offset/size %u/%u for slave SII"
-                " size %zu!\n", data.offset, data.nwords, slave->sii_nwords);
+                " size %zu!\n", data.offset, data.nwords, slave->sii_image->nwords);
         return -EINVAL;
     }
 
     if (copy_to_user((void __user *) data.words,
-                slave->sii_words + data.offset, data.nwords * 2))
+                slave->sii_image->words + data.offset, data.nwords * 2))
         retval = -EFAULT;
     else
         retval = 0;
diff --git a/master/mailbox.c b/master/mailbox.c
--- a/master/mailbox.c
+++ b/master/mailbox.c
@@ -57,7 +57,13 @@ uint8_t *ec_slave_mbox_prepare_send(cons
     size_t total_size;
     int ret;
 
-    if (unlikely(!slave->sii.mailbox_protocols)) {
+    if (unlikely(!slave->sii_image)) {
+        EC_SLAVE_ERR(slave, "Slave cannot verify if mailbox communication"
+                " is supported!\n");
+        return ERR_PTR(-EAGAIN);
+    }
+
+    if (unlikely(!slave->sii_image->sii.mailbox_protocols)) {
         EC_SLAVE_ERR(slave, "Slave does not support mailbox"
                 " communication!\n");
         return ERR_PTR(-EPROTONOSUPPORT);
diff --git a/master/master.c b/master/master.c
--- a/master/master.c
+++ b/master/master.c
@@ -184,6 +184,7 @@ int ec_master_init(ec_master_t *master, 
 
     INIT_LIST_HEAD(&master->configs);
     INIT_LIST_HEAD(&master->domains);
+    INIT_LIST_HEAD(&master->sii_images);
 
     master->app_time = 0ULL;
     master->app_start_time = 0ULL;
@@ -427,6 +428,7 @@ void ec_master_clear(
     ec_master_clear_domains(master);
     ec_master_clear_slave_configs(master);
     ec_master_clear_slaves(master);
+    ec_master_clear_sii_images(master);
 
     ec_datagram_clear(&master->sync_mon_datagram);
     ec_datagram_clear(&master->sync64_datagram);
@@ -485,6 +487,66 @@ void ec_master_clear_slave_configs(ec_ma
 
 /*****************************************************************************/
 
+/** Clear the SII data.
+ */
+void ec_sii_image_clear(ec_sii_image_t *sii_image)
+{
+    unsigned int i;
+    ec_pdo_t *pdo, *next_pdo;
+
+    // free all sync managers
+    if (sii_image->sii.syncs) {
+        for (i = 0; i < sii_image->sii.sync_count; i++) {
+            ec_sync_clear(&sii_image->sii.syncs[i]);
+        }
+        kfree(sii_image->sii.syncs);
+        sii_image->sii.syncs = NULL;
+    }
+
+    // free all strings
+    if (sii_image->sii.strings) {
+        for (i = 0; i < sii_image->sii.string_count; i++)
+            kfree(sii_image->sii.strings[i]);
+        kfree(sii_image->sii.strings);
+    }
+
+    // free all SII PDOs
+    list_for_each_entry_safe(pdo, next_pdo, &sii_image->sii.pdos, list) {
+        list_del(&pdo->list);
+        ec_pdo_clear(pdo);
+        kfree(pdo);
+    }
+
+    if (sii_image->words) {
+        kfree(sii_image->words);
+    }
+}
+
+/*****************************************************************************/
+
+/** Clear the SII data applied during bus scanning.
+ */
+void ec_master_clear_sii_images(
+        ec_master_t *master /**< EtherCAT master. */
+        )
+{
+    ec_sii_image_t *sii_image, *next;
+
+    list_for_each_entry_safe(sii_image, next, &master->sii_images, list) {
+#if EC_REUSE_SII_IMAGE
+        if ((master->phase != EC_OPERATION) ||
+           ((sii_image->sii.serial_number == 0) && (sii_image->sii.alias == 0)))
+#endif
+        {
+            list_del(&sii_image->list);
+            ec_sii_image_clear(sii_image);
+            kfree(sii_image);
+        }
+    }
+}
+
+/*****************************************************************************/
+
 /** Clear all slaves.
  */
 void ec_master_clear_slaves(ec_master_t *master)
@@ -691,6 +753,7 @@ void ec_master_leave_idle_phase(ec_maste
 
     ec_lock_down(&master->master_sem);
     ec_master_clear_slaves(master);
+    ec_master_clear_sii_images(master);
     ec_lock_up(&master->master_sem);
 
     ec_fsm_master_reset(&master->fsm);
@@ -2955,13 +3018,19 @@ int ecrt_master_get_slave(ec_master_t *m
        goto out_get_slave;
     }
 
+    if (slave->sii_image == NULL) {
+        EC_MASTER_WARN(master, "Cannot access SII data from slave position %u", slave->ring_position);
+        ret = -ENOENT;
+        goto out_get_slave;
+    }
+
     slave_info->position = slave->ring_position;
-    slave_info->vendor_id = slave->sii.vendor_id;
-    slave_info->product_code = slave->sii.product_code;
-    slave_info->revision_number = slave->sii.revision_number;
-    slave_info->serial_number = slave->sii.serial_number;
+    slave_info->vendor_id = slave->sii_image->sii.vendor_id;
+    slave_info->product_code = slave->sii_image->sii.product_code;
+    slave_info->revision_number = slave->sii_image->sii.revision_number;
+    slave_info->serial_number = slave->sii_image->sii.serial_number;
     slave_info->alias = slave->effective_alias;
-    slave_info->current_on_ebus = slave->sii.current_on_ebus;
+    slave_info->current_on_ebus = slave->sii_image->sii.current_on_ebus;
 
     for (i = 0; i < EC_MAX_PORTS; i++) {
         slave_info->ports[i].desc = slave->ports[i].desc;
@@ -2983,10 +3052,10 @@ int ecrt_master_get_slave(ec_master_t *m
 
     slave_info->al_state = slave->current_state;
     slave_info->error_flag = slave->error_flag;
-    slave_info->sync_count = slave->sii.sync_count;
+    slave_info->sync_count = slave->sii_image->sii.sync_count;
     slave_info->sdo_count = ec_slave_sdo_count(slave);
-    if (slave->sii.name) {
-        strncpy(slave_info->name, slave->sii.name, EC_MAX_STRING_LENGTH);
+    if (slave->sii_image->sii.name) {
+        strncpy(slave_info->name, slave->sii_image->sii.name, EC_MAX_STRING_LENGTH);
     } else {
         slave_info->name[0] = 0;
     }
diff --git a/master/master.h b/master/master.h
--- a/master/master.h
+++ b/master/master.h
@@ -230,6 +230,9 @@ struct ec_master {
     struct list_head configs; /**< List of slave configurations. */
     struct list_head domains; /**< List of domains. */
 
+    /* Configuration applied during bus scanning. */
+    struct list_head sii_images; /**< List of slave SII images. */
+
     u64 app_time; /**< Time of the last ecrt_master_sync() call. */
     u64 app_start_time; /**< Application start time. */
     u8 has_app_time; /**< Application time is valid. */
@@ -321,6 +324,8 @@ int ec_master_init(ec_master_t *, unsign
         const uint8_t *, dev_t, struct class *, unsigned int);
 void ec_master_clear(ec_master_t *);
 
+void ec_sii_image_clear(ec_sii_image_t *);
+
 /** Number of Ethernet devices.
  */
 #if EC_MAX_NUM_DEVICES > 1
@@ -359,6 +364,7 @@ void ec_master_output_stats(ec_master_t 
 void ec_master_clear_eoe_handlers(ec_master_t *);
 #endif
 void ec_master_clear_slaves(ec_master_t *);
+void ec_master_clear_sii_images(ec_master_t *);
 
 unsigned int ec_master_config_count(const ec_master_t *);
 ec_slave_config_t *ec_master_get_config(
diff --git a/master/slave.c b/master/slave.c
--- a/master/slave.c
+++ b/master/slave.c
@@ -71,10 +71,15 @@ void ec_slave_init(
 
     slave->master = master;
     slave->device_index = dev_idx;
+
     slave->ring_position = ring_position;
     slave->station_address = station_address;
     slave->effective_alias = 0x0000;
-
+#if EC_REUSE_SII_IMAGE
+    slave->effective_vendor_id = 0x00000000;
+    slave->effective_product_code = 0x00000000;
+    slave->effective_serial_number = 0x00000000;
+#endif
     slave->config = NULL;
     slave->requested_state = EC_SLAVE_STATE_PREOP;
     slave->current_state = EC_SLAVE_STATE_UNKNOWN;
@@ -97,7 +102,6 @@ void ec_slave_init(
         slave->ports[i].link.link_up = 0;
         slave->ports[i].link.loop_closed = 1;
         slave->ports[i].link.signal_detected = 0;
-        slave->sii.physical_layer[i] = 0xFF;
 
         slave->ports[i].receive_time = 0U;
 
@@ -116,40 +120,8 @@ void ec_slave_init(
     slave->has_dc_system_time = 0;
     slave->transmission_delay = 0U;
 
-    slave->sii_words = NULL;
-    slave->sii_nwords = 0;
+    slave->sii_image = NULL;
 
-    slave->sii.alias = 0x0000;
-    slave->sii.vendor_id = 0x00000000;
-    slave->sii.product_code = 0x00000000;
-    slave->sii.revision_number = 0x00000000;
-    slave->sii.serial_number = 0x00000000;
-    slave->sii.boot_rx_mailbox_offset = 0x0000;
-    slave->sii.boot_rx_mailbox_size = 0x0000;
-    slave->sii.boot_tx_mailbox_offset = 0x0000;
-    slave->sii.boot_tx_mailbox_size = 0x0000;
-    slave->sii.std_rx_mailbox_offset = 0x0000;
-    slave->sii.std_rx_mailbox_size = 0x0000;
-    slave->sii.std_tx_mailbox_offset = 0x0000;
-    slave->sii.std_tx_mailbox_size = 0x0000;
-    slave->sii.mailbox_protocols = 0;
-
-    slave->sii.strings = NULL;
-    slave->sii.string_count = 0;
-
-    slave->sii.has_general = 0;
-    slave->sii.group = NULL;
-    slave->sii.image = NULL;
-    slave->sii.order = NULL;
-    slave->sii.name = NULL;
-    memset(&slave->sii.coe_details, 0x00, sizeof(ec_sii_coe_details_t));
-    memset(&slave->sii.general_flags, 0x00, sizeof(ec_sii_general_flags_t));
-    slave->sii.current_on_ebus = 0;
-
-    slave->sii.syncs = NULL;
-    slave->sii.sync_count = 0;
-
-    INIT_LIST_HEAD(&slave->sii.pdos);
 
     INIT_LIST_HEAD(&slave->sdo_dictionary);
 
@@ -181,6 +153,51 @@ void ec_slave_init(
 }
 
 
+void ec_slave_sii_image_init(
+        ec_sii_image_t *sii_image /**< SII image */
+        )
+{
+    unsigned int i;
+
+    sii_image->words = NULL;
+    sii_image->nwords = 0;
+
+    sii_image->sii.alias = 0x0000;
+    sii_image->sii.vendor_id = 0x00000000;
+    sii_image->sii.product_code = 0x00000000;
+    sii_image->sii.revision_number = 0x00000000;
+    sii_image->sii.serial_number = 0x00000000;
+    sii_image->sii.boot_rx_mailbox_offset = 0x0000;
+    sii_image->sii.boot_rx_mailbox_size = 0x0000;
+    sii_image->sii.boot_tx_mailbox_offset = 0x0000;
+    sii_image->sii.boot_tx_mailbox_size = 0x0000;
+    sii_image->sii.std_rx_mailbox_offset = 0x0000;
+    sii_image->sii.std_rx_mailbox_size = 0x0000;
+    sii_image->sii.std_tx_mailbox_offset = 0x0000;
+    sii_image->sii.std_tx_mailbox_size = 0x0000;
+    sii_image->sii.mailbox_protocols = 0;
+    sii_image->sii.strings = NULL;
+    sii_image->sii.string_count = 0;
+
+    sii_image->sii.has_general = 0;
+    sii_image->sii.group = NULL;
+    sii_image->sii.image = NULL;
+    sii_image->sii.order = NULL;
+    sii_image->sii.name = NULL;
+    memset(&sii_image->sii.coe_details, 0x00, sizeof(ec_sii_coe_details_t));
+    memset(&sii_image->sii.general_flags, 0x00, sizeof(ec_sii_general_flags_t));
+    sii_image->sii.current_on_ebus = 0;
+
+    sii_image->sii.syncs = NULL;
+    sii_image->sii.sync_count = 0;
+
+    INIT_LIST_HEAD(&sii_image->sii.pdos);
+
+    for (i = 0; i < EC_MAX_PORTS; i++) {
+        sii_image->sii.physical_layer[i] = 0xFF;
+    }
+}
+
 /*****************************************************************************/
 
 /**
@@ -223,8 +240,6 @@ int ec_read_mbox_locked(ec_slave_t *slav
 void ec_slave_clear(ec_slave_t *slave /**< EtherCAT slave */)
 {
     ec_sdo_t *sdo, *next_sdo;
-    unsigned int i;
-    ec_pdo_t *pdo, *next_pdo;
 
     // abort all pending requests
 
@@ -295,26 +310,6 @@ void ec_slave_clear(ec_slave_t *slave /*
         kfree(sdo);
     }
 
-    // free all strings
-    if (slave->sii.strings) {
-        for (i = 0; i < slave->sii.string_count; i++)
-            kfree(slave->sii.strings[i]);
-        kfree(slave->sii.strings);
-    }
-
-    // free all sync managers
-    ec_slave_clear_sync_managers(slave);
-
-    // free all SII PDOs
-    list_for_each_entry_safe(pdo, next_pdo, &slave->sii.pdos, list) {
-        list_del(&pdo->list);
-        ec_pdo_clear(pdo);
-        kfree(pdo);
-    }
-
-    if (slave->sii_words) {
-        kfree(slave->sii_words);
-    }
 
     // free mailbox response data
 #ifdef EC_EOE
@@ -336,12 +331,12 @@ void ec_slave_clear_sync_managers(ec_sla
 {
     unsigned int i;
 
-    if (slave->sii.syncs) {
-        for (i = 0; i < slave->sii.sync_count; i++) {
-            ec_sync_clear(&slave->sii.syncs[i]);
+    if (slave->sii_image && slave->sii_image->sii.syncs) {
+        for (i = 0; i < slave->sii_image->sii.sync_count; i++) {
+            ec_sync_clear(&slave->sii_image->sii.syncs[i]);
         }
-        kfree(slave->sii.syncs);
-        slave->sii.syncs = NULL;
+        kfree(slave->sii_image->sii.syncs);
+        slave->sii_image->sii.syncs = NULL;
     }
 }
 
@@ -439,11 +434,16 @@ int ec_slave_fetch_sii_strings(
     size_t size;
     off_t offset;
 
-    slave->sii.string_count = data[0];
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "SII data not attached!\n");
+        return -EINVAL;
+    }
 
-    if (slave->sii.string_count) {
-        if (!(slave->sii.strings =
-                    kmalloc(sizeof(char *) * slave->sii.string_count,
+    slave->sii_image->sii.string_count = data[0];
+
+    if (slave->sii_image->sii.string_count) {
+        if (!(slave->sii_image->sii.strings =
+                    kmalloc(sizeof(char *) * slave->sii_image->sii.string_count,
                         GFP_KERNEL))) {
             EC_SLAVE_ERR(slave, "Failed to allocate string array memory.\n");
             err = -ENOMEM;
@@ -451,17 +451,17 @@ int ec_slave_fetch_sii_strings(
         }
 
         offset = 1;
-        for (i = 0; i < slave->sii.string_count; i++) {
+        for (i = 0; i < slave->sii_image->sii.string_count; i++) {
             size = data[offset];
             // allocate memory for string structure and data at a single blow
-            if (!(slave->sii.strings[i] =
+            if (!(slave->sii_image->sii.strings[i] =
                         kmalloc(sizeof(char) * size + 1, GFP_KERNEL))) {
                 EC_SLAVE_ERR(slave, "Failed to allocate string memory.\n");
                 err = -ENOMEM;
                 goto out_free;
             }
-            memcpy(slave->sii.strings[i], data + offset + 1, size);
-            slave->sii.strings[i][size] = 0x00; // append binary zero
+            memcpy(slave->sii_image->sii.strings[i], data + offset + 1, size);
+            slave->sii_image->sii.strings[i][size] = 0x00; // append binary zero
             offset += 1 + size;
         }
     }
@@ -470,11 +470,11 @@ int ec_slave_fetch_sii_strings(
 
 out_free:
     for (i--; i >= 0; i--)
-        kfree(slave->sii.strings[i]);
-    kfree(slave->sii.strings);
-    slave->sii.strings = NULL;
+        kfree(slave->sii_image->sii.strings[i]);
+    kfree(slave->sii_image->sii.strings);
+    slave->sii_image->sii.strings = NULL;
 out_zero:
-    slave->sii.string_count = 0;
+    slave->sii_image->sii.string_count = 0;
     return err;
 }
 
@@ -500,31 +500,36 @@ int ec_slave_fetch_sii_general(
         return -EINVAL;
     }
 
-    slave->sii.group = ec_slave_sii_string(slave, data[0]);
-    slave->sii.image = ec_slave_sii_string(slave, data[1]);
-    slave->sii.order = ec_slave_sii_string(slave, data[2]);
-    slave->sii.name = ec_slave_sii_string(slave, data[3]);
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "SII data not attached!\n");
+        return -EINVAL;
+    }
+
+    slave->sii_image->sii.group = ec_slave_sii_string(slave, data[0]);
+    slave->sii_image->sii.image = ec_slave_sii_string(slave, data[1]);
+    slave->sii_image->sii.order = ec_slave_sii_string(slave, data[2]);
+    slave->sii_image->sii.name = ec_slave_sii_string(slave, data[3]);
 
     for (i = 0; i < 4; i++)
-        slave->sii.physical_layer[i] =
+        slave->sii_image->sii.physical_layer[i] =
             (data[4] & (0x03 << (i * 2))) >> (i * 2);
 
     // read CoE details
     flags = EC_READ_U8(data + 5);
-    slave->sii.coe_details.enable_sdo =                 (flags >> 0) & 0x01;
-    slave->sii.coe_details.enable_sdo_info =            (flags >> 1) & 0x01;
-    slave->sii.coe_details.enable_pdo_assign =          (flags >> 2) & 0x01;
-    slave->sii.coe_details.enable_pdo_configuration =   (flags >> 3) & 0x01;
-    slave->sii.coe_details.enable_upload_at_startup =   (flags >> 4) & 0x01;
-    slave->sii.coe_details.enable_sdo_complete_access = (flags >> 5) & 0x01;
+    slave->sii_image->sii.coe_details.enable_sdo =                 (flags >> 0) & 0x01;
+    slave->sii_image->sii.coe_details.enable_sdo_info =            (flags >> 1) & 0x01;
+    slave->sii_image->sii.coe_details.enable_pdo_assign =          (flags >> 2) & 0x01;
+    slave->sii_image->sii.coe_details.enable_pdo_configuration =   (flags >> 3) & 0x01;
+    slave->sii_image->sii.coe_details.enable_upload_at_startup =   (flags >> 4) & 0x01;
+    slave->sii_image->sii.coe_details.enable_sdo_complete_access = (flags >> 5) & 0x01;
 
     // read general flags
     flags = EC_READ_U8(data + 0x000B);
-    slave->sii.general_flags.enable_safeop =  (flags >> 0) & 0x01;
-    slave->sii.general_flags.enable_not_lrw = (flags >> 1) & 0x01;
+    slave->sii_image->sii.general_flags.enable_safeop =  (flags >> 0) & 0x01;
+    slave->sii_image->sii.general_flags.enable_not_lrw = (flags >> 1) & 0x01;
 
-    slave->sii.current_on_ebus = EC_READ_S16(data + 0x0C);
-    slave->sii.has_general = 1;
+    slave->sii_image->sii.current_on_ebus = EC_READ_S16(data + 0x0C);
+    slave->sii_image->sii.has_general = 1;
     return 0;
 }
 
@@ -555,10 +560,15 @@ int ec_slave_fetch_sii_syncs(
         return -EINVAL;
     }
 
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "SII data not attached!\n");
+        return -EINVAL;
+    }
+
     count = data_size / 8;
 
     if (count) {
-        total_count = count + slave->sii.sync_count;
+        total_count = count + slave->sii_image->sii.sync_count;
         if (total_count > EC_MAX_SYNC_MANAGERS) {
             EC_SLAVE_ERR(slave, "Exceeded maximum number of"
                     " sync managers!\n");
@@ -571,12 +581,12 @@ int ec_slave_fetch_sii_syncs(
             return -ENOMEM;
         }
 
-        for (i = 0; i < slave->sii.sync_count; i++)
-            ec_sync_init_copy(syncs + i, slave->sii.syncs + i);
+        for (i = 0; i < slave->sii_image->sii.sync_count; i++)
+            ec_sync_init_copy(syncs + i, slave->sii_image->sii.syncs + i);
 
         // initialize new sync managers
         for (i = 0; i < count; i++, data += 8) {
-            index = i + slave->sii.sync_count;
+            index = i + slave->sii_image->sii.sync_count;
             sync = &syncs[index];
 
             ec_sync_init(sync, slave);
@@ -586,10 +596,10 @@ int ec_slave_fetch_sii_syncs(
             sync->enable = EC_READ_U8(data + 6);
         }
 
-        if (slave->sii.syncs)
-            kfree(slave->sii.syncs);
-        slave->sii.syncs = syncs;
-        slave->sii.sync_count = total_count;
+        if (slave->sii_image->sii.syncs)
+            kfree(slave->sii_image->sii.syncs);
+        slave->sii_image->sii.syncs = syncs;
+        slave->sii_image->sii.sync_count = total_count;
     }
 
     return 0;
@@ -614,6 +624,11 @@ int ec_slave_fetch_sii_pdos(
     ec_pdo_entry_t *entry;
     unsigned int entry_count, i;
 
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "SII data not attached!\n");
+        return -EINVAL;
+    }
+
     while (data_size >= 8) {
         if (!(pdo = kmalloc(sizeof(ec_pdo_t), GFP_KERNEL))) {
             EC_SLAVE_ERR(slave, "Failed to allocate PDO memory.\n");
@@ -631,7 +646,7 @@ int ec_slave_fetch_sii_pdos(
             kfree(pdo);
             return ret;
         }
-        list_add_tail(&pdo->list, &slave->sii.pdos);
+        list_add_tail(&pdo->list, &slave->sii_image->sii.pdos);
 
         data_size -= 8;
         data += 8;
@@ -693,12 +708,17 @@ char *ec_slave_sii_string(
     if (!index--)
         return NULL;
 
-    if (index >= slave->sii.string_count) {
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "SII data not attached!\n");
+        return NULL;
+    }
+
+    if (index >= slave->sii_image->sii.string_count) {
         EC_SLAVE_DBG(slave, 1, "String %u not found.\n", index);
         return NULL;
     }
 
-    return slave->sii.strings[index];
+    return slave->sii_image->sii.strings[index];
 }
 
 /*****************************************************************************/
@@ -712,8 +732,14 @@ ec_sync_t *ec_slave_get_sync(
         uint8_t sync_index /**< Sync manager index. */
         )
 {
-    if (sync_index < slave->sii.sync_count) {
-        return &slave->sii.syncs[sync_index];
+
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "SII data not attached!\n");
+        return NULL;
+    }
+
+    if (sync_index < slave->sii_image->sii.sync_count) {
+        return &slave->sii_image->sii.syncs[sync_index];
     } else {
         return NULL;
     }
@@ -851,8 +877,13 @@ const ec_pdo_t *ec_slave_find_pdo(
     const ec_sync_t *sync;
     const ec_pdo_t *pdo;
 
-    for (i = 0; i < slave->sii.sync_count; i++) {
-        sync = &slave->sii.syncs[i];
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "SII data not attached!\n");
+        return NULL;
+    }
+
+    for (i = 0; i < slave->sii_image->sii.sync_count; i++) {
+        sync = &slave->sii_image->sii.syncs[i];
 
         if (!(pdo = ec_pdo_list_find_pdo_const(&sync->pdos, index)))
             continue;
@@ -906,8 +937,13 @@ void ec_slave_attach_pdo_names(
     ec_sync_t *sync;
     ec_pdo_t *pdo;
 
-    for (i = 0; i < slave->sii.sync_count; i++) {
-        sync = slave->sii.syncs + i;
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "SII data not attached!\n");
+        return;
+    }
+
+    for (i = 0; i < slave->sii_image->sii.sync_count; i++) {
+        sync = slave->sii_image->sii.syncs + i;
         list_for_each_entry(pdo, &sync->pdos.list, list) {
             ec_slave_find_names_for_pdo(slave, pdo);
         }
diff --git a/master/slave.h b/master/slave.h
--- a/master/slave.h
+++ b/master/slave.h
@@ -152,7 +152,7 @@ typedef struct {
 
 /*****************************************************************************/
 
-/** Slave information interface data.
+/** Extracted slave information interface data.
  */
 typedef struct {
     // Non-category data
@@ -196,6 +196,19 @@ typedef struct {
 
 /*****************************************************************************/
 
+/** Complete slave information interface data image.
+ */
+typedef struct {
+    struct list_head list; /**< List item. */
+
+    uint16_t *words;
+    size_t nwords; /**< Size of the SII contents in words. */
+
+    ec_sii_t sii; /**< Extracted SII data. */
+} ec_sii_image_t;
+
+/*****************************************************************************/
+
 /** EtherCAT slave.
  */
 struct ec_slave
@@ -208,7 +221,12 @@ struct ec_slave
     uint16_t ring_position; /**< Ring position. */
     uint16_t station_address; /**< Configured station address. */
     uint16_t effective_alias; /**< Effective alias address. */
-
+    // identification
+#if EC_REUSE_SII_IMAGE
+    uint32_t effective_vendor_id; /**< Effective vendor ID. */
+    uint32_t effective_product_code; /**< Effective product code. */
+    uint32_t effective_serial_number; /**< Effective serial number. */
+#endif
     ec_slave_port_t ports[EC_MAX_PORTS]; /**< Ports. */
 
     // configuration
@@ -240,12 +258,8 @@ struct ec_slave
     uint32_t transmission_delay; /**< DC system time transmission delay
                                    (offset from reference clock). */
 
-    // SII
-    uint16_t *sii_words; /**< Complete SII image. */
-    size_t sii_nwords; /**< Size of the SII contents in words. */
-
     // Slave information interface
-    ec_sii_t sii; /**< Extracted SII data. */
+    ec_sii_image_t *sii_image;  /**< Current complete SII image. */
 
     struct list_head sdo_dictionary; /**< SDO dictionary list */
     uint8_t sdo_dictionary_fetched; /**< Dictionary has been fetched. */
@@ -279,6 +293,9 @@ struct ec_slave
 // slave construction/destruction
 void ec_slave_init(ec_slave_t *, ec_master_t *, ec_device_index_t,
         uint16_t, uint16_t);
+
+void ec_slave_sii_image_init(ec_sii_image_t *);
+
 void ec_slave_clear(ec_slave_t *);
 
 void ec_slave_clear_sync_managers(ec_slave_t *);
diff --git a/master/slave_config.c b/master/slave_config.c
--- a/master/slave_config.c
+++ b/master/slave_config.c
@@ -259,16 +259,21 @@ int ec_slave_config_attach(
         return -EEXIST;
     }
 
+    if (!slave->sii_image) {
+        EC_CONFIG_DBG(sc, 1, "Slave cannot access its SII data!\n");
+        return -EAGAIN;
+    }
+
     if (
 #ifdef EC_IDENT_WILDCARDS
             sc->vendor_id != 0xffffffff &&
 #endif
-            slave->sii.vendor_id != sc->vendor_id
+            slave->sii_image->sii.vendor_id != sc->vendor_id
        ) {
         EC_CONFIG_DBG(sc, 1, "Slave %s-%u has no matching vendor ID (0x%08X)"
                 " for configuration (0x%08X).\n",
                 ec_device_names[slave->device_index!=0], slave->ring_position,
-                slave->sii.vendor_id, sc->vendor_id);
+                slave->sii_image->sii.vendor_id, sc->vendor_id);
         return -EINVAL;
     }
 
@@ -276,12 +281,12 @@ int ec_slave_config_attach(
 #ifdef EC_IDENT_WILDCARDS
             sc->product_code != 0xffffffff &&
 #endif
-            slave->sii.product_code != sc->product_code
+            slave->sii_image->sii.product_code != sc->product_code
        ) {
         EC_CONFIG_DBG(sc, 1, "Slave %s-%u has no matching product code (0x%08X)"
                 " for configuration (0x%08X).\n",
                 ec_device_names[slave->device_index!=0], slave->ring_position,
-                slave->sii.product_code, sc->product_code);
+                slave->sii_image->sii.product_code, sc->product_code);
         return -EINVAL;
     }
 
@@ -367,9 +372,14 @@ void ec_slave_config_load_default_mappin
     EC_CONFIG_DBG(sc, 1, "Loading default mapping for PDO 0x%04X.\n",
             pdo->index);
 
+    if (!sc->slave->sii_image) {
+        EC_CONFIG_DBG(sc, 1, "Slave cannot access its SII data!\n");
+        return;
+    }
+
     // find PDO in any sync manager (it could be reassigned later)
-    for (i = 0; i < sc->slave->sii.sync_count; i++) {
-        sync = &sc->slave->sii.syncs[i];
+    for (i = 0; i < sc->slave->sii_image->sii.sync_count; i++) {
+        sync = &sc->slave->sii_image->sii.syncs[i];
 
         list_for_each_entry(default_pdo, &sync->pdos.list, list) {
             if (default_pdo->index != pdo->index)
@@ -967,7 +977,7 @@ int ecrt_slave_config_sdo(ec_slave_confi
             "subindex = 0x%02X, data = 0x%p, size = %zu)\n",
             __func__, sc, index, subindex, data, size);
 
-    if (slave && !(slave->sii.mailbox_protocols & EC_MBOX_COE)) {
+    if (slave && slave->sii_image && !(slave->sii_image->sii.mailbox_protocols & EC_MBOX_COE)) {
         EC_CONFIG_WARN(sc, "Attached slave does not support CoE!\n");
     }
 
@@ -1051,7 +1061,7 @@ int ecrt_slave_config_complete_sdo(ec_sl
     EC_CONFIG_DBG(sc, 1, "%s(sc = 0x%p, index = 0x%04X, "
             "data = 0x%p, size = %zu)\n", __func__, sc, index, data, size);
 
-    if (slave && !(slave->sii.mailbox_protocols & EC_MBOX_COE)) {
+    if (slave && !(slave->sii_image->sii.mailbox_protocols & EC_MBOX_COE)) {
         EC_CONFIG_WARN(sc, "Attached slave does not support CoE!\n");
     }
 
@@ -1287,7 +1297,7 @@ int ecrt_slave_config_idn(ec_slave_confi
         return -EINVAL;
     }
 
-    if (slave && !(slave->sii.mailbox_protocols & EC_MBOX_SOE)) {
+    if (slave && slave->sii_image && !(slave->sii_image->sii.mailbox_protocols & EC_MBOX_SOE)) {
         EC_CONFIG_WARN(sc, "Attached slave does not support SoE!\n");
     }
 
diff --git a/master/voe_handler.c b/master/voe_handler.c
--- a/master/voe_handler.c
+++ b/master/voe_handler.c
@@ -217,7 +217,15 @@ void ec_voe_handler_state_write_start(ec
         ec_print_data(ecrt_voe_handler_data(voe), voe->data_size);
     }
 
-    if (!(slave->sii.mailbox_protocols & EC_MBOX_VOE)) {
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave cannot process VoE write request."
+                " SII data not available.\n");
+        voe->state = ec_voe_handler_state_error;
+        voe->request_state = EC_INT_REQUEST_FAILURE;
+        return;
+    }
+
+    if (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_VOE)) {
         EC_SLAVE_ERR(slave, "Slave does not support VoE!\n");
         voe->state = ec_voe_handler_state_error;
         voe->request_state = EC_INT_REQUEST_FAILURE;
@@ -297,7 +305,14 @@ void ec_voe_handler_state_read_start(ec_
 
     EC_SLAVE_DBG(slave, 1, "Reading VoE data.\n");
 
-    if (!(slave->sii.mailbox_protocols & EC_MBOX_VOE)) {
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave not ready to process VoE request\n");
+        voe->state = ec_voe_handler_state_error;
+        voe->request_state = EC_INT_REQUEST_FAILURE;
+        return;
+    }
+
+    if (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_VOE)) {
         EC_SLAVE_ERR(slave, "Slave does not support VoE!\n");
         voe->state = ec_voe_handler_state_error;
         voe->request_state = EC_INT_REQUEST_FAILURE;
@@ -496,7 +511,15 @@ void ec_voe_handler_state_read_nosync_st
 
     EC_SLAVE_DBG(slave, 1, "Reading VoE data.\n");
 
-    if (!(slave->sii.mailbox_protocols & EC_MBOX_VOE)) {
+    if (!slave->sii_image) {
+        EC_SLAVE_ERR(slave, "Slave cannot process VoE read request."
+                " SII data not available.\n");
+        voe->state = ec_voe_handler_state_error;
+        voe->request_state = EC_INT_REQUEST_FAILURE;
+        return;
+    }
+
+    if (!(slave->sii_image->sii.mailbox_protocols & EC_MBOX_VOE)) {
         EC_SLAVE_ERR(slave, "Slave does not support VoE!\n");
         voe->state = ec_voe_handler_state_error;
         voe->request_state = EC_INT_REQUEST_FAILURE;
