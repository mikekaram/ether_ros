From: Gavin Lambert <gavinl@compacsort.com>
Date: Tue, 31 May 2016 23:57:06 +0200

If --enable-rtmutex, use rtmutexes instead of semaphores.

Allows priority inheritance, limiting impact from lower priority tasks on
lock contention, especially on -rt kernels.

Includes former patches 0007 and 0037 and updated for RTAI safety.

Updated for 3.17 & 3.14.34-rt32 thanks to Esben Haabendal <esben@haabendal.dk>

diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -865,6 +865,35 @@ else
 fi
 
 #------------------------------------------------------------------------------
+# Realtime Mutex support
+#------------------------------------------------------------------------------
+
+AC_MSG_CHECKING([whether to use rtmutexes])
+
+AC_ARG_ENABLE([rtmutex],
+    AS_HELP_STRING([--enable-rtmutex],
+                   [Use rtmutexes for synchronization (default: no)]),
+    [
+        case "${enableval}" in
+            yes) rtmutex=1
+                ;;
+            no) rtmutex=0
+                ;;
+            *) AC_MSG_ERROR([Invalid value for --enable-rtmutex])
+                ;;
+        esac
+    ],
+    [rtmutex=0]
+)
+
+if test "x${rtmutex}" = "x1"; then
+    AC_DEFINE([EC_USE_RTMUTEX], [1], [Use rtmutex for synchronization])
+    AC_MSG_RESULT([yes])
+else
+    AC_MSG_RESULT([no])
+fi
+
+#------------------------------------------------------------------------------
 # High-resolution timer support
 #------------------------------------------------------------------------------
 
diff --git a/master/Makefile.am b/master/Makefile.am
--- a/master/Makefile.am
+++ b/master/Makefile.am
@@ -57,7 +57,7 @@ noinst_HEADERS = \
 	globals.h \
 	ioctl.c ioctl.h \
 	mailbox.c mailbox.h \
-	master.c master.h \
+	master.c master.h locks.h \
 	module.c \
 	pdo.c pdo.h \
 	pdo_entry.c pdo_entry.h \
diff --git a/master/device.c b/master/device.c
--- a/master/device.c
+++ b/master/device.c
@@ -559,9 +559,9 @@ void ecdev_withdraw(ec_device_t *device 
 
     EC_MASTER_INFO(master, "Releasing %s device %s.\n", dev_str, mac_str);
 
-    down(&master->device_sem);
+    ec_lock_down(&master->device_sem);
     ec_device_detach(device);
-    up(&master->device_sem);
+    ec_lock_up(&master->device_sem);
 }
 
 /*****************************************************************************/
diff --git a/master/domain.c b/master/domain.c
--- a/master/domain.c
+++ b/master/domain.c
@@ -512,14 +512,14 @@ void ecrt_domain_external_memory(ec_doma
     EC_MASTER_DBG(domain->master, 1, "ecrt_domain_external_memory("
             "domain = 0x%p, mem = 0x%p)\n", domain, mem);
 
-    down(&domain->master->master_sem);
+    ec_lock_down(&domain->master->master_sem);
 
     ec_domain_clear_data(domain);
 
     domain->data = mem;
     domain->data_origin = EC_ORIG_EXTERNAL;
 
-    up(&domain->master->master_sem);
+    ec_lock_up(&domain->master->master_sem);
 }
 
 /*****************************************************************************/
diff --git a/master/ethernet.c b/master/ethernet.c
--- a/master/ethernet.c
+++ b/master/ethernet.c
@@ -153,7 +153,7 @@ int ec_eoe_init(
     eoe->tx_queue_size = EC_EOE_TX_QUEUE_SIZE;
     eoe->tx_queued_frames = 0;
 
-    sema_init(&eoe->tx_queue_sem, 1);
+    ec_lock_init(&eoe->tx_queue_sem);
     eoe->tx_frame_number = 0xFF;
     memset(&eoe->stats, 0, sizeof(struct net_device_stats));
 
@@ -323,7 +323,7 @@ void ec_eoe_flush(ec_eoe_t *eoe /**< EoE
 {
     ec_eoe_frame_t *frame, *next;
 
-    down(&eoe->tx_queue_sem);
+    ec_lock_down(&eoe->tx_queue_sem);
 
     list_for_each_entry_safe(frame, next, &eoe->tx_queue, queue) {
         list_del(&frame->queue);
@@ -332,7 +332,7 @@ void ec_eoe_flush(ec_eoe_t *eoe /**< EoE
     }
     eoe->tx_queued_frames = 0;
 
-    up(&eoe->tx_queue_sem);
+    ec_lock_up(&eoe->tx_queue_sem);
 }
 
 /*****************************************************************************/
@@ -727,10 +727,10 @@ void ec_eoe_state_tx_start(ec_eoe_t *eoe
         return;
     }
 
-    down(&eoe->tx_queue_sem);
+    ec_lock_down(&eoe->tx_queue_sem);
 
     if (!eoe->tx_queued_frames || list_empty(&eoe->tx_queue)) {
-        up(&eoe->tx_queue_sem);
+        ec_lock_up(&eoe->tx_queue_sem);
         eoe->tx_idle = 1;
         // no data available.
         // start a new receive immediately.
@@ -751,7 +751,7 @@ void ec_eoe_state_tx_start(ec_eoe_t *eoe
     }
 
     eoe->tx_queued_frames--;
-    up(&eoe->tx_queue_sem);
+    ec_lock_up(&eoe->tx_queue_sem);
 
     eoe->tx_idle = 0;
 
@@ -923,14 +923,14 @@ int ec_eoedev_tx(struct sk_buff *skb, /*
 
     frame->skb = skb;
 
-    down(&eoe->tx_queue_sem);
+    ec_lock_down(&eoe->tx_queue_sem);
     list_add_tail(&frame->queue, &eoe->tx_queue);
     eoe->tx_queued_frames++;
     if (eoe->tx_queued_frames == eoe->tx_queue_size) {
         netif_stop_queue(dev);
         eoe->tx_queue_active = 0;
     }
-    up(&eoe->tx_queue_sem);
+    ec_lock_up(&eoe->tx_queue_sem);
 
 #if EOE_DEBUG_LEVEL >= 2
     EC_SLAVE_DBG(eoe->slave, 0, "EoE %s TX queued frame"
diff --git a/master/ethernet.h b/master/ethernet.h
--- a/master/ethernet.h
+++ b/master/ethernet.h
@@ -40,13 +40,8 @@
 #include <linux/list.h>
 #include <linux/netdevice.h>
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-#include <linux/semaphore.h>
-#else
-#include <asm/semaphore.h>
-#endif
-
 #include "globals.h"
+#include "locks.h"
 #include "slave.h"
 #include "datagram.h"
 
@@ -109,7 +104,7 @@ struct ec_eoe
     unsigned int tx_queue_size; /**< Transmit queue size. */
     unsigned int tx_queue_active; /**< kernel netif queue started */
     unsigned int tx_queued_frames; /**< number of frames in the queue */
-    struct semaphore tx_queue_sem; /**< Semaphore for the send queue. */
+    ec_lock_t tx_queue_sem; /**< Semaphore for the send queue. */
     ec_eoe_frame_t *tx_frame; /**< current TX frame */
     uint8_t tx_frame_number; /**< number of the transmitted frame */
     uint8_t tx_fragment_number; /**< number of the fragment */
diff --git a/master/fsm_master.c b/master/fsm_master.c
--- a/master/fsm_master.c
+++ b/master/fsm_master.c
@@ -327,15 +327,15 @@ void ec_fsm_master_state_broadcast(
     }
 
     if (fsm->rescan_required) {
-        down(&master->scan_sem);
+        ec_lock_down(&master->scan_sem);
         if (!master->allow_scan) {
-            up(&master->scan_sem);
+            ec_lock_up(&master->scan_sem);
         } else {
             unsigned int count = 0, next_dev_slave, ring_position;
             ec_device_index_t dev_idx;
 
             master->scan_busy = 1;
-            up(&master->scan_sem);
+            ec_lock_up(&master->scan_sem);
 
             // clear all slaves and scan the bus
             fsm->rescan_required = 0;
@@ -795,9 +795,9 @@ void ec_fsm_master_action_configure(
                 || slave->force_config) && !slave->error_flag) {
 
         // Start slave configuration
-        down(&master->config_sem);
+        ec_lock_down(&master->config_sem);
         master->config_busy = 1;
-        up(&master->config_sem);
+        ec_lock_up(&master->config_sem);
 
         if (master->debug_level) {
             char old_state[EC_STATE_STRING_SIZE],
diff --git a/master/ioctl.c b/master/ioctl.c
--- a/master/ioctl.c
+++ b/master/ioctl.c
@@ -109,7 +109,7 @@ static ATTRIBUTES int ec_ioctl_master(
     ec_ioctl_master_t io;
     unsigned int dev_idx, j;
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
@@ -123,9 +123,9 @@ static ATTRIBUTES int ec_ioctl_master(
     io.active = (uint8_t) master->active;
     io.scan_busy = master->scan_busy;
 
-    up(&master->master_sem);
-
-    if (down_interruptible(&master->device_sem)) {
+    ec_lock_up(&master->master_sem);
+
+    if (ec_lock_down_interruptible(&master->device_sem)) {
         return -EINTR;
     }
 
@@ -177,7 +177,7 @@ static ATTRIBUTES int ec_ioctl_master(
             master->device_stats.loss_rates[j];
     }
 
-    up(&master->device_sem);
+    ec_lock_up(&master->device_sem);
 
     io.app_time = master->app_time;
     io.ref_clock =
@@ -209,12 +209,12 @@ static ATTRIBUTES int ec_ioctl_slave(
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_DBG(master, 1, "Slave %u does not exist!\n", data.position);
         return -EINVAL;
     }
@@ -269,7 +269,7 @@ static ATTRIBUTES int ec_ioctl_slave(
     ec_ioctl_strcpy(data.order, slave->sii.order);
     ec_ioctl_strcpy(data.name, slave->sii.name);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
@@ -296,19 +296,19 @@ static ATTRIBUTES int ec_ioctl_slave_syn
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
     }
 
     if (data.sync_index >= slave->sii.sync_count) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "Sync manager %u does not exist!\n",
                 data.sync_index);
         return -EINVAL;
@@ -322,7 +322,7 @@ static ATTRIBUTES int ec_ioctl_slave_syn
     data.enable = sync->enable;
     data.pdo_count = ec_pdo_list_count(&sync->pdos);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
@@ -350,19 +350,19 @@ static ATTRIBUTES int ec_ioctl_slave_syn
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
     }
 
     if (data.sync_index >= slave->sii.sync_count) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "Sync manager %u does not exist!\n",
                 data.sync_index);
         return -EINVAL;
@@ -371,7 +371,7 @@ static ATTRIBUTES int ec_ioctl_slave_syn
     sync = &slave->sii.syncs[data.sync_index];
     if (!(pdo = ec_pdo_list_find_pdo_by_pos_const(
                     &sync->pdos, data.pdo_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "Sync manager %u does not contain a PDO with "
                 "position %u!\n", data.sync_index, data.pdo_pos);
         return -EINVAL;
@@ -381,7 +381,7 @@ static ATTRIBUTES int ec_ioctl_slave_syn
     data.entry_count = ec_pdo_entry_count(pdo);
     ec_ioctl_strcpy(data.name, pdo->name);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
@@ -410,19 +410,19 @@ static ATTRIBUTES int ec_ioctl_slave_syn
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
     }
 
     if (data.sync_index >= slave->sii.sync_count) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "Sync manager %u does not exist!\n",
                 data.sync_index);
         return -EINVAL;
@@ -431,7 +431,7 @@ static ATTRIBUTES int ec_ioctl_slave_syn
     sync = &slave->sii.syncs[data.sync_index];
     if (!(pdo = ec_pdo_list_find_pdo_by_pos_const(
                     &sync->pdos, data.pdo_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "Sync manager %u does not contain a PDO with "
                 "position %u!\n", data.sync_index, data.pdo_pos);
         return -EINVAL;
@@ -439,7 +439,7 @@ static ATTRIBUTES int ec_ioctl_slave_syn
 
     if (!(entry = ec_pdo_find_entry_by_pos_const(
                     pdo, data.entry_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "PDO 0x%04X does not contain an entry with "
                 "position %u!\n", data.pdo_pos, data.entry_pos);
         return -EINVAL;
@@ -450,7 +450,7 @@ static ATTRIBUTES int ec_ioctl_slave_syn
     data.bit_length = entry->bit_length;
     ec_ioctl_strcpy(data.name, entry->name);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
@@ -477,11 +477,11 @@ static ATTRIBUTES int ec_ioctl_domain(
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(domain = ec_master_find_domain_const(master, data.index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Domain %u does not exist!\n", data.index);
         return -EINVAL;
     }
@@ -495,7 +495,7 @@ static ATTRIBUTES int ec_ioctl_domain(
     data.expected_working_counter = domain->expected_working_counter;
     data.fmmu_count = ec_domain_fmmu_count(domain);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
@@ -522,18 +522,18 @@ static ATTRIBUTES int ec_ioctl_domain_fm
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(domain = ec_master_find_domain_const(master, data.domain_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Domain %u does not exist!\n",
                 data.domain_index);
         return -EINVAL;
     }
 
     if (!(fmmu = ec_domain_find_fmmu(domain, data.fmmu_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Domain %u has less than %u"
                 " fmmu configurations.\n",
                 data.domain_index, data.fmmu_index + 1);
@@ -547,7 +547,7 @@ static ATTRIBUTES int ec_ioctl_domain_fm
     data.logical_address = fmmu->domain->logical_base_address + fmmu->logical_domain_offset;
     data.data_size = fmmu->data_size;
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
@@ -573,18 +573,18 @@ static ATTRIBUTES int ec_ioctl_domain_da
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(domain = ec_master_find_domain_const(master, data.domain_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Domain %u does not exist!\n",
                 data.domain_index);
         return -EINVAL;
     }
 
     if (domain->data_size != data.data_size) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Data size mismatch %u/%zu!\n",
                 data.data_size, domain->data_size);
         return -EFAULT;
@@ -592,11 +592,11 @@ static ATTRIBUTES int ec_ioctl_domain_da
 
     if (copy_to_user((void __user *) data.target, domain->data,
                 domain->data_size)) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -EFAULT;
     }
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
     return 0;
 }
 
@@ -647,12 +647,12 @@ static ATTRIBUTES int ec_ioctl_slave_sta
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
@@ -660,7 +660,7 @@ static ATTRIBUTES int ec_ioctl_slave_sta
 
     ec_slave_request_state(slave, data.al_state);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
     return 0;
 }
 
@@ -683,12 +683,12 @@ static ATTRIBUTES int ec_ioctl_slave_sdo
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
@@ -696,7 +696,7 @@ static ATTRIBUTES int ec_ioctl_slave_sdo
 
     if (!(sdo = ec_slave_get_sdo_by_pos_const(
                     slave, data.sdo_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "SDO %u does not exist!\n", data.sdo_position);
         return -EINVAL;
     }
@@ -705,7 +705,7 @@ static ATTRIBUTES int ec_ioctl_slave_sdo
     data.max_subindex = sdo->max_subindex;
     ec_ioctl_strcpy(data.name, sdo->name);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
@@ -733,12 +733,12 @@ static ATTRIBUTES int ec_ioctl_slave_sdo
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
@@ -747,14 +747,14 @@ static ATTRIBUTES int ec_ioctl_slave_sdo
     if (data.sdo_spec <= 0) {
         if (!(sdo = ec_slave_get_sdo_by_pos_const(
                         slave, -data.sdo_spec))) {
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             EC_SLAVE_ERR(slave, "SDO %u does not exist!\n", -data.sdo_spec);
             return -EINVAL;
         }
     } else {
         if (!(sdo = ec_slave_get_sdo_const(
                         slave, data.sdo_spec))) {
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             EC_SLAVE_ERR(slave, "SDO 0x%04X does not exist!\n",
                     data.sdo_spec);
             return -EINVAL;
@@ -763,7 +763,7 @@ static ATTRIBUTES int ec_ioctl_slave_sdo
 
     if (!(entry = ec_sdo_get_entry_const(
                     sdo, data.sdo_entry_subindex))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "SDO entry 0x%04X:%02X does not exist!\n",
                 sdo->index, data.sdo_entry_subindex);
         return -EINVAL;
@@ -785,7 +785,7 @@ static ATTRIBUTES int ec_ioctl_slave_sdo
         entry->write_access[EC_SDO_ENTRY_ACCESS_OP];
     ec_ioctl_strcpy(data.description, entry->description);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
@@ -906,12 +906,12 @@ static ATTRIBUTES int ec_ioctl_slave_sii
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(slave = ec_master_find_slave_const(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         return -EINVAL;
@@ -919,7 +919,7 @@ static ATTRIBUTES int ec_ioctl_slave_sii
 
     if (!data.nwords
             || data.offset + data.nwords > slave->sii_nwords) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_SLAVE_ERR(slave, "Invalid SII read offset/size %u/%u for slave SII"
                 " size %zu!\n", data.offset, data.nwords, slave->sii_nwords);
         return -EINVAL;
@@ -931,7 +931,7 @@ static ATTRIBUTES int ec_ioctl_slave_sii
     else
         retval = 0;
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
     return retval;
 }
 
@@ -973,14 +973,14 @@ static ATTRIBUTES int ec_ioctl_slave_sii
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         kfree(words);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(
                     master, 0, data.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 data.slave_position);
         kfree(words);
@@ -998,21 +998,21 @@ static ATTRIBUTES int ec_ioctl_slave_sii
     // schedule SII write request.
     list_add_tail(&request.list, &master->sii_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             // abort request
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             kfree(words);
             return -EINTR;
         }
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -1055,14 +1055,14 @@ static ATTRIBUTES int ec_ioctl_slave_reg
 
     ecrt_reg_request_read(&request, io.address, io.size);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_reg_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(
                     master, 0, io.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         ec_reg_request_clear(&request);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 io.slave_position);
@@ -1072,21 +1072,21 @@ static ATTRIBUTES int ec_ioctl_slave_reg
     // schedule request.
     list_add_tail(&request.list, &slave->reg_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             // abort request
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_reg_request_clear(&request);
             return -EINTR;
         }
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -1139,7 +1139,7 @@ static ATTRIBUTES int ec_ioctl_slave_reg
 
     ecrt_reg_request_write(&request, io.address, io.size);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_reg_request_clear(&request);
         return -EINTR;
     }
@@ -1151,7 +1151,7 @@ static ATTRIBUTES int ec_ioctl_slave_reg
     }
     else {
         if (!(slave = ec_master_find_slave(master, 0, io.slave_position))) {
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_reg_request_clear(&request);
             EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                     io.slave_position);
@@ -1162,21 +1162,21 @@ static ATTRIBUTES int ec_ioctl_slave_reg
         list_add_tail(&request.list, &slave->reg_requests);
     }
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             // abort request
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_reg_request_clear(&request);
             return -EINTR;
         }
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -1206,12 +1206,12 @@ static ATTRIBUTES int ec_ioctl_config(
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config_const(
                     master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave config %u does not exist!\n",
                 data.config_index);
         return -EINVAL;
@@ -1237,7 +1237,7 @@ static ATTRIBUTES int ec_ioctl_config(
         data.dc_sync[i] = sc->dc_sync[i];
     }
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
@@ -1270,12 +1270,12 @@ static ATTRIBUTES int ec_ioctl_config_pd
         return -EINVAL;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config_const(
                     master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave config %u does not exist!\n",
                 data.config_index);
         return -EINVAL;
@@ -1284,7 +1284,7 @@ static ATTRIBUTES int ec_ioctl_config_pd
     if (!(pdo = ec_pdo_list_find_pdo_by_pos_const(
                     &sc->sync_configs[data.sync_index].pdos,
                     data.pdo_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Invalid PDO position!\n");
         return -EINVAL;
     }
@@ -1293,7 +1293,7 @@ static ATTRIBUTES int ec_ioctl_config_pd
     data.entry_count = ec_pdo_entry_count(pdo);
     ec_ioctl_strcpy(data.name, pdo->name);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
@@ -1327,12 +1327,12 @@ static ATTRIBUTES int ec_ioctl_config_pd
         return -EINVAL;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config_const(
                     master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave config %u does not exist!\n",
                 data.config_index);
         return -EINVAL;
@@ -1341,14 +1341,14 @@ static ATTRIBUTES int ec_ioctl_config_pd
     if (!(pdo = ec_pdo_list_find_pdo_by_pos_const(
                     &sc->sync_configs[data.sync_index].pdos,
                     data.pdo_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Invalid PDO position!\n");
         return -EINVAL;
     }
 
     if (!(entry = ec_pdo_find_entry_by_pos_const(
                     pdo, data.entry_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Entry not found!\n");
         return -EINVAL;
     }
@@ -1358,7 +1358,7 @@ static ATTRIBUTES int ec_ioctl_config_pd
     data.bit_length = entry->bit_length;
     ec_ioctl_strcpy(data.name, entry->name);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
@@ -1390,14 +1390,14 @@ static ATTRIBUTES int ec_ioctl_config_sd
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         kfree(ioctl);
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config_const(
                     master, ioctl->config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave config %u does not exist!\n",
                 ioctl->config_index);
         kfree(ioctl);
@@ -1406,7 +1406,7 @@ static ATTRIBUTES int ec_ioctl_config_sd
 
     if (!(req = ec_slave_config_get_sdo_by_pos_const(
                     sc, ioctl->sdo_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Invalid SDO position!\n");
         kfree(ioctl);
         return -EINVAL;
@@ -1419,7 +1419,7 @@ static ATTRIBUTES int ec_ioctl_config_sd
             min((u32) ioctl->size, (u32) EC_MAX_SDO_DATA_SIZE));
     ioctl->complete_access = req->complete_access;
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, ioctl, sizeof(*ioctl))) {
         kfree(ioctl);
@@ -1454,14 +1454,14 @@ static ATTRIBUTES int ec_ioctl_config_id
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         kfree(ioctl);
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config_const(
                     master, ioctl->config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave config %u does not exist!\n",
                 ioctl->config_index);
         kfree(ioctl);
@@ -1470,7 +1470,7 @@ static ATTRIBUTES int ec_ioctl_config_id
 
     if (!(req = ec_slave_config_get_idn_by_pos_const(
                     sc, ioctl->idn_pos))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Invalid IDN position!\n");
         kfree(ioctl);
         return -EINVAL;
@@ -1483,7 +1483,7 @@ static ATTRIBUTES int ec_ioctl_config_id
     memcpy(ioctl->data, req->data,
             min((u32) ioctl->size, (u32) EC_MAX_IDN_DATA_SIZE));
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, ioctl, sizeof(*ioctl))) {
         kfree(ioctl);
@@ -1514,11 +1514,11 @@ static ATTRIBUTES int ec_ioctl_eoe_handl
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(eoe = ec_master_get_eoe_handler_const(master, data.eoe_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "EoE handler %u does not exist!\n",
                 data.eoe_index);
         return -EINVAL;
@@ -1538,7 +1538,7 @@ static ATTRIBUTES int ec_ioctl_eoe_handl
     data.tx_queued_frames = eoe->tx_queued_frames;
     data.tx_queue_size = eoe->tx_queue_size;
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
@@ -1586,13 +1586,13 @@ static ATTRIBUTES int ec_ioctl_slave_eoe
 
     req.state = EC_INT_REQUEST_QUEUED;
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(
                     master, 0, io.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 io.slave_position);
         return -EINVAL;
@@ -1603,20 +1603,20 @@ static ATTRIBUTES int ec_ioctl_slave_eoe
     // schedule request.
     list_add_tail(&req.list, &slave->eoe_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 req.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (req.state == EC_INT_REQUEST_QUEUED) {
             // abort request
             list_del(&req.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             return -EINTR;
         }
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -1709,7 +1709,7 @@ static ATTRIBUTES int ec_ioctl_create_sl
 
     data.config_index = 0;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     list_for_each_entry(entry, &master->configs, list) {
@@ -1718,7 +1718,7 @@ static ATTRIBUTES int ec_ioctl_create_sl
         data.config_index++;
     }
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     if (copy_to_user((void __user *) arg, &data, sizeof(data)))
         return -EFAULT;
@@ -1747,7 +1747,7 @@ static ATTRIBUTES int ec_ioctl_select_re
         goto out_return;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ret = -EINTR;
         goto out_return;
     }
@@ -1762,7 +1762,7 @@ static ATTRIBUTES int ec_ioctl_select_re
     ecrt_master_select_reference_clock(master, sc);
 
 out_up:
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 out_return:
     return ret;
 }
@@ -1798,14 +1798,14 @@ static ATTRIBUTES int ec_ioctl_setup_dom
 
         ctx->process_data_size = 0;
 
-        if (down_interruptible(&master->master_sem))
+        if (ec_lock_down_interruptible(&master->master_sem))
             return -EINTR;
 
         list_for_each_entry(domain, &master->domains, list) {
             ctx->process_data_size += ecrt_domain_size(domain);
         }
 
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
 
         if (ctx->process_data_size) {
             ctx->process_data = vmalloc(ctx->process_data_size);
@@ -1882,14 +1882,14 @@ static ATTRIBUTES int ec_ioctl_activate(
 
         ctx->process_data_size = 0;
 
-        if (down_interruptible(&master->master_sem))
+        if (ec_lock_down_interruptible(&master->master_sem))
             return -EINTR;
 
         list_for_each_entry(domain, &master->domains, list) {
             ctx->process_data_size += ecrt_domain_size(domain);
         }
 
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
 
         if (ctx->process_data_size) {
             ctx->process_data = vmalloc(ctx->process_data_size);
@@ -2006,12 +2006,12 @@ static ATTRIBUTES int ec_ioctl_set_send_
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     ec_master_set_send_interval(master, send_interval);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
     return 0;
 }
 
@@ -2320,9 +2320,9 @@ static ATTRIBUTES int ec_ioctl_reset(
         ec_ioctl_context_t *ctx /**< Private data structure of file handle. */
         )
 {
-    down(&master->master_sem);
+    ec_lock_down(&master->master_sem);
     ecrt_master_reset(master);
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
     return 0;
 }
 
@@ -2353,7 +2353,7 @@ static ATTRIBUTES int ec_ioctl_sc_sync(
         goto out_return;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ret = -EINTR;
         goto out_return;
     }
@@ -2374,7 +2374,7 @@ static ATTRIBUTES int ec_ioctl_sc_sync(
     }
 
 out_up:
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 out_return:
     return ret;
 }
@@ -2405,7 +2405,7 @@ static ATTRIBUTES int ec_ioctl_sc_watchd
         goto out_return;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ret = -EINTR;
         goto out_return;
     }
@@ -2419,7 +2419,7 @@ static ATTRIBUTES int ec_ioctl_sc_watchd
             data.watchdog_divider, data.watchdog_intervals);
 
 out_up:
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 out_return:
     return ret;
 }
@@ -2448,7 +2448,7 @@ static ATTRIBUTES int ec_ioctl_sc_allow_
         goto out_return;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ret = -EINTR;
         goto out_return;
     }
@@ -2462,7 +2462,7 @@ static ATTRIBUTES int ec_ioctl_sc_allow_
             data.allow_overlapping_pdos);
 
 out_up:
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 out_return:
     return ret;
 }
@@ -2487,15 +2487,15 @@ static ATTRIBUTES int ec_ioctl_sc_add_pd
     if (copy_from_user(&data, (void __user *) arg, sizeof(data)))
         return -EFAULT;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     return ecrt_slave_config_pdo_assign_add(sc, data.sync_index, data.index);
 }
@@ -2521,15 +2521,15 @@ static ATTRIBUTES int ec_ioctl_sc_clear_
     if (copy_from_user(&data, (void __user *) arg, sizeof(data)))
         return -EFAULT;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     ecrt_slave_config_pdo_assign_clear(sc, data.sync_index);
     return 0;
@@ -2556,15 +2556,15 @@ static ATTRIBUTES int ec_ioctl_sc_add_en
     if (copy_from_user(&data, (void __user *) arg, sizeof(data)))
         return -EFAULT;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     return ecrt_slave_config_pdo_mapping_add(sc, data.pdo_index,
             data.entry_index, data.entry_subindex, data.entry_bit_length);
@@ -2591,15 +2591,15 @@ static ATTRIBUTES int ec_ioctl_sc_clear_
     if (copy_from_user(&data, (void __user *) arg, sizeof(data)))
         return -EFAULT;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     ecrt_slave_config_pdo_mapping_clear(sc, data.index);
     return 0;
@@ -2628,20 +2628,20 @@ static ATTRIBUTES int ec_ioctl_sc_reg_pd
     if (copy_from_user(&data, (void __user *) arg, sizeof(data)))
         return -EFAULT;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
     if (!(domain = ec_master_find_domain(master, data.domain_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc or domain could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc or domain could be invalidated */
 
     ret = ecrt_slave_config_reg_pdo_entry(sc, data.entry_index,
             data.entry_subindex, domain, &data.bit_position);
@@ -2677,21 +2677,21 @@ static ATTRIBUTES int ec_ioctl_sc_reg_pd
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config(master, io.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
     if (!(domain = ec_master_find_domain(master, io.domain_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc or domain could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc or domain could be invalidated */
 
     ret = ecrt_slave_config_reg_pdo_entry_pos(sc, io.sync_index,
             io.pdo_pos, io.entry_pos, domain, &io.bit_position);
@@ -2723,11 +2723,11 @@ static ATTRIBUTES int ec_ioctl_sc_dc(
     if (copy_from_user(&data, (void __user *) arg, sizeof(data)))
         return -EFAULT;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
@@ -2737,7 +2737,7 @@ static ATTRIBUTES int ec_ioctl_sc_dc(
             data.dc_sync[1].cycle_time,
             data.dc_sync[1].shift_time);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     return 0;
 }
@@ -2777,18 +2777,18 @@ static ATTRIBUTES int ec_ioctl_sc_sdo(
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         kfree(sdo_data);
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config(master, data.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         kfree(sdo_data);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     if (data.complete_access) {
         ret = ecrt_slave_config_complete_sdo(sc,
@@ -2823,18 +2823,18 @@ static ATTRIBUTES int ec_ioctl_sc_emerg_
     if (copy_from_user(&io, (void __user *) arg, sizeof(io)))
         return -EFAULT;
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config(master, io.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
     ret = ecrt_slave_config_emerg_size(sc, io.size);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     return ret;
 }
@@ -2986,12 +2986,12 @@ static ATTRIBUTES int ec_ioctl_sc_create
 
     data.request_index = 0;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     sc = ec_master_get_config(master, data.config_index);
     if (!sc) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
@@ -2999,7 +2999,7 @@ static ATTRIBUTES int ec_ioctl_sc_create
         data.request_index++;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     req = ecrt_slave_config_create_sdo_request_err(sc, data.sdo_index,
             data.sdo_subindex, data.size);
@@ -3038,13 +3038,13 @@ static ATTRIBUTES int ec_ioctl_sc_create
 
     io.request_index = 0;
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
     sc = ec_master_get_config(master, io.config_index);
     if (!sc) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
@@ -3052,7 +3052,7 @@ static ATTRIBUTES int ec_ioctl_sc_create
         io.request_index++;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     reg = ecrt_slave_config_create_reg_request_err(sc, io.mem_size);
     if (IS_ERR(reg)) {
@@ -3091,12 +3091,12 @@ static ATTRIBUTES int ec_ioctl_sc_create
 
     data.voe_index = 0;
 
-    if (down_interruptible(&master->master_sem))
+    if (ec_lock_down_interruptible(&master->master_sem))
         return -EINTR;
 
     sc = ec_master_get_config(master, data.config_index);
     if (!sc) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         return -ENOENT;
     }
 
@@ -3104,7 +3104,7 @@ static ATTRIBUTES int ec_ioctl_sc_create
         data.voe_index++;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     voe = ecrt_slave_config_create_voe_handler_err(sc, data.size);
     if (IS_ERR(voe))
@@ -3189,18 +3189,18 @@ static ATTRIBUTES int ec_ioctl_sc_idn(
         return -EFAULT;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         kfree(data);
         return -EINTR;
     }
 
     if (!(sc = ec_master_get_config(master, ioctl.config_index))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         kfree(data);
         return -ENOENT;
     }
 
-    up(&master->master_sem); /** \todo sc could be invalidated */
+    ec_lock_up(&master->master_sem); /** \todo sc could be invalidated */
 
     ret = ecrt_slave_config_idn(
             sc, ioctl.drive_no, ioctl.idn, ioctl.al_state, data, ioctl.size);
@@ -3226,19 +3226,19 @@ static ATTRIBUTES int ec_ioctl_domain_si
         return -EPERM;
     }
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
     list_for_each_entry(domain, &master->domains, list) {
         if (domain->index == (unsigned long) arg) {
             size_t size = ecrt_domain_size(domain);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             return size;
         }
     }
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
     return -ENOENT;
 }
 
@@ -3260,19 +3260,19 @@ static ATTRIBUTES int ec_ioctl_domain_of
     if (unlikely(!ctx->requested))
         return -EPERM;
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
     list_for_each_entry(domain, &master->domains, list) {
         if (domain->index == (unsigned long) arg) {
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             return offset;
         }
         offset += ecrt_domain_size(domain);
     }
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
     return -ENOENT;
 }
 
@@ -4127,13 +4127,13 @@ static ATTRIBUTES int ec_ioctl_slave_foe
 
     ec_foe_request_read(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_foe_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, io.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         ec_foe_request_clear(&request);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 io.slave_position);
@@ -4145,21 +4145,21 @@ static ATTRIBUTES int ec_ioctl_slave_foe
     // schedule request.
     list_add_tail(&request.list, &slave->foe_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_foe_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -4231,13 +4231,13 @@ static ATTRIBUTES int ec_ioctl_slave_foe
     request.data_size = io.buffer_size;
     ec_foe_request_write(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_foe_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, io.slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 io.slave_position);
         ec_foe_request_clear(&request);
@@ -4249,21 +4249,21 @@ static ATTRIBUTES int ec_ioctl_slave_foe
     // schedule FoE write request.
     list_add_tail(&request.list, &slave->foe_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             // abort request
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_foe_request_clear(&request);
             return -EINTR;
         }
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
diff --git a/master/locks.h b/master/locks.h
new file mode 100644
--- /dev/null
+++ b/master/locks.h
@@ -0,0 +1,78 @@
+/******************************************************************************
+ *
+ *  $Id$
+ *
+ *  Copyright (C) 2006-2008  Florian Pose, Ingenieurgemeinschaft IgH
+ *
+ *  This file is part of the IgH EtherCAT Master.
+ *
+ *  The IgH EtherCAT Master is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License version 2, as
+ *  published by the Free Software Foundation.
+ *
+ *  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with the IgH EtherCAT Master; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  ---
+ *
+ *  The license mentioned above concerns the source code only. Using the
+ *  EtherCAT technology and brand is only permitted in compliance with the
+ *  industrial property and similar rights of Beckhoff Automation GmbH.
+ *
+ *****************************************************************************/
+
+/**
+   \file
+   Abstract locks
+*/
+
+/*****************************************************************************/
+
+#ifndef __EC_LOCKS_H__
+#define __EC_LOCKS_H__
+
+#include "globals.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+#include <linux/semaphore.h>
+#else
+#include <asm/semaphore.h>
+#endif
+
+/*****************************************************************************/
+
+#ifdef EC_USE_RTMUTEX
+
+typedef struct rt_mutex ec_lock_t;
+
+static inline void ec_lock_init(ec_lock_t *sem) { rt_mutex_init(sem); }
+static inline void ec_lock_down(ec_lock_t *sem) { rt_mutex_lock(sem); }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 34)
+static inline int ec_lock_down_interruptible(ec_lock_t *sem) { return rt_mutex_lock_interruptible(sem); }
+#else
+static inline int ec_lock_down_interruptible(ec_lock_t *sem) { return rt_mutex_lock_interruptible(sem, 1); }
+#endif
+static inline void ec_lock_up(ec_lock_t *sem) { rt_mutex_unlock(sem); }
+
+#else
+
+typedef struct semaphore ec_lock_t;
+
+static inline void ec_lock_init(ec_lock_t *sem) { sema_init(sem, 1); }
+static inline void ec_lock_down(ec_lock_t *sem) { down(sem); }
+static inline int ec_lock_down_interruptible(ec_lock_t *sem) { return down_interruptible(sem); }
+static inline void ec_lock_up(ec_lock_t *sem) { up(sem); }
+
+#endif
+
+/*****************************************************************************/
+
+#endif
+
+/*****************************************************************************/
diff --git a/master/master.c b/master/master.c
--- a/master/master.c
+++ b/master/master.c
@@ -150,7 +150,7 @@ int ec_master_init(ec_master_t *master, 
     master->index = index;
     master->reserved = 0;
 
-    sema_init(&master->master_sem, 1);
+    ec_lock_init(&master->master_sem);
 
     for (dev_idx = EC_DEVICE_MAIN; dev_idx < EC_MAX_NUM_DEVICES; dev_idx++) {
         master->macs[dev_idx] = NULL;
@@ -169,7 +169,7 @@ int ec_master_init(ec_master_t *master, 
 
     ec_master_clear_device_stats(master);
 
-    sema_init(&master->device_sem, 1);
+    ec_lock_init(&master->device_sem);
 
     master->phase = EC_ORPHANED;
     master->active = 0;
@@ -190,18 +190,18 @@ int ec_master_init(ec_master_t *master, 
 
     master->scan_busy = 0;
     master->allow_scan = 1;
-    sema_init(&master->scan_sem, 1);
+    ec_lock_init(&master->scan_sem);
     init_waitqueue_head(&master->scan_queue);
 
     master->config_busy = 0;
-    sema_init(&master->config_sem, 1);
+    ec_lock_init(&master->config_sem);
     init_waitqueue_head(&master->config_queue);
 
     INIT_LIST_HEAD(&master->datagram_queue);
     master->datagram_index = 0;
 
     INIT_LIST_HEAD(&master->ext_datagram_queue);
-    sema_init(&master->ext_queue_sem, 1);
+    ec_lock_init(&master->ext_queue_sem);
 
     master->ext_ring_idx_rt = 0;
     master->ext_ring_idx_fsm = 0;
@@ -233,7 +233,7 @@ int ec_master_init(ec_master_t *master, 
     INIT_LIST_HEAD(&master->eoe_handlers);
 #endif
 
-    sema_init(&master->io_sem, 1);
+    ec_lock_init(&master->io_sem);
     master->send_cb = NULL;
     master->receive_cb = NULL;
     master->cb_data = NULL;
@@ -546,10 +546,10 @@ void ec_master_clear_config(
         ec_master_t *master /**< EtherCAT master. */
         )
 {
-    down(&master->master_sem);
+    ec_lock_down(&master->master_sem);
     ec_master_clear_domains(master);
     ec_master_clear_slave_configs(master);
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 }
 
 /*****************************************************************************/
@@ -561,9 +561,9 @@ void ec_master_internal_send_cb(
         )
 {
     ec_master_t *master = (ec_master_t *) cb_data;
-    down(&master->io_sem);
+    ec_lock_down(&master->io_sem);
     ecrt_master_send_ext(master);
-    up(&master->io_sem);
+    ec_lock_up(&master->io_sem);
 }
 
 /*****************************************************************************/
@@ -575,9 +575,9 @@ void ec_master_internal_receive_cb(
         )
 {
     ec_master_t *master = (ec_master_t *) cb_data;
-    down(&master->io_sem);
+    ec_lock_down(&master->io_sem);
     ecrt_master_receive(master);
-    up(&master->io_sem);
+    ec_lock_up(&master->io_sem);
 }
 
 /*****************************************************************************/
@@ -686,9 +686,9 @@ void ec_master_leave_idle_phase(ec_maste
 #endif
     ec_master_thread_stop(master);
 
-    down(&master->master_sem);
+    ec_lock_down(&master->master_sem);
     ec_master_clear_slaves(master);
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     ec_fsm_master_reset(&master->fsm);
 }
@@ -708,9 +708,9 @@ int ec_master_enter_operation_phase(
 
     EC_MASTER_DBG(master, 1, "IDLE -> OPERATION.\n");
 
-    down(&master->config_sem);
+    ec_lock_down(&master->config_sem);
     if (master->config_busy) {
-        up(&master->config_sem);
+        ec_lock_up(&master->config_sem);
 
         // wait for slave configuration to complete
         ret = wait_event_interruptible(master->config_queue,
@@ -724,15 +724,15 @@ int ec_master_enter_operation_phase(
         EC_MASTER_DBG(master, 1, "Waiting for pending slave"
                 " configuration returned.\n");
     } else {
-        up(&master->config_sem);
+        ec_lock_up(&master->config_sem);
     }
 
-    down(&master->scan_sem);
+    ec_lock_down(&master->scan_sem);
     master->allow_scan = 0; // 'lock' the slave list
     if (!master->scan_busy) {
-        up(&master->scan_sem);
+        ec_lock_up(&master->scan_sem);
     } else {
-        up(&master->scan_sem);
+        ec_lock_up(&master->scan_sem);
 
         // wait for slave scan to complete
         ret = wait_event_interruptible(master->scan_queue,
@@ -980,9 +980,9 @@ void ec_master_queue_datagram_ext(
         ec_datagram_t *datagram /**< datagram */
         )
 {
-    down(&master->ext_queue_sem);
+    ec_lock_down(&master->ext_queue_sem);
     list_add_tail(&datagram->queue, &master->ext_datagram_queue);
-    up(&master->ext_queue_sem);
+    ec_lock_up(&master->ext_queue_sem);
 }
 
 /*****************************************************************************/
@@ -1590,12 +1590,12 @@ static int ec_master_idle_thread(void *p
         ec_datagram_output_stats(&master->fsm_datagram);
 
         // receive
-        down(&master->io_sem);
+        ec_lock_down(&master->io_sem);
         ecrt_master_receive(master);
-        up(&master->io_sem);
+        ec_lock_up(&master->io_sem);
 
         // execute master & slave state machines
-        if (down_interruptible(&master->master_sem)) {
+        if (ec_lock_down_interruptible(&master->master_sem)) {
             break;
         }
 
@@ -1603,15 +1603,15 @@ static int ec_master_idle_thread(void *p
 
         ec_master_exec_slave_fsms(master);
 
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
 
         // queue and send
-        down(&master->io_sem);
+        ec_lock_down(&master->io_sem);
         if (fsm_exec) {
             ec_master_queue_datagram(master, &master->fsm_datagram);
         }
         sent_bytes = ecrt_master_send(master);
-        up(&master->io_sem);
+        ec_lock_up(&master->io_sem);
 
         if (ec_fsm_master_idle(&master->fsm)) {
 #ifdef EC_USE_HRTIMER
@@ -1655,7 +1655,7 @@ static int ec_master_operation_thread(vo
             ec_master_output_stats(master);
 
             // execute master & slave state machines
-            if (down_interruptible(&master->master_sem)) {
+            if (ec_lock_down_interruptible(&master->master_sem)) {
                 break;
             }
 
@@ -1667,7 +1667,7 @@ static int ec_master_operation_thread(vo
 
             ec_master_exec_slave_fsms(master);
 
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
         }
 
 #ifdef EC_USE_HRTIMER
@@ -1788,9 +1788,9 @@ static int ec_master_eoe_thread(void *pr
                 ec_eoe_queue(eoe);
             }
             // (try to) send datagrams
-            down(&master->ext_queue_sem);
+            ec_lock_down(&master->ext_queue_sem);
             master->send_cb(master->cb_data);
-            up(&master->ext_queue_sem);
+            ec_lock_up(&master->ext_queue_sem);
         }
 
 schedule:
@@ -2316,7 +2316,7 @@ ec_domain_t *ecrt_master_create_domain_e
         return ERR_PTR(-ENOMEM);
     }
 
-    down(&master->master_sem);
+    ec_lock_down(&master->master_sem);
 
     if (list_empty(&master->domains)) {
         index = 0;
@@ -2328,7 +2328,7 @@ ec_domain_t *ecrt_master_create_domain_e
     ec_domain_init(domain, master, index);
     list_add_tail(&domain->list, &master->domains);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     EC_MASTER_DBG(master, 1, "Created domain %u.\n", domain->index);
 
@@ -2371,21 +2371,21 @@ int ecrt_master_activate(ec_master_t *ma
         return 0;
     }
 
-    down(&master->master_sem);
+    ec_lock_down(&master->master_sem);
 
     // finish all domains
     domain_offset = 0;
     list_for_each_entry(domain, &master->domains, list) {
         ret = ec_domain_finish(domain, domain_offset);
         if (ret < 0) {
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             EC_MASTER_ERR(master, "Failed to finish domain 0x%p!\n", domain);
             return ret;
         }
         domain_offset += domain->data_size;
     }
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // restart EoE process and master thread with new locking
 
@@ -2712,14 +2712,14 @@ ec_slave_config_t *ecrt_master_slave_con
         ec_slave_config_init(sc, master,
                 alias, position, vendor_id, product_code);
 
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
 
         // try to find the addressed slave
         ec_slave_config_attach(sc);
         ec_slave_config_load_default_sync_config(sc);
         list_add_tail(&sc->list, &master->configs);
 
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     return sc;
@@ -2783,7 +2783,7 @@ int ecrt_master_get_slave(ec_master_t *m
     unsigned int i;
     int ret = 0;
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         return -EINTR;
     }
 
@@ -2831,7 +2831,7 @@ int ecrt_master_get_slave(ec_master_t *m
     }
 
 out_get_slave:
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     return ret;
 }
@@ -3029,13 +3029,13 @@ int ecrt_master_sdo_download(ec_master_t
     request.data_size = data_size;
     ecrt_sdo_request_write(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_sdo_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n", slave_position);
         ec_sdo_request_clear(&request);
         return -EINVAL;
@@ -3046,21 +3046,21 @@ int ecrt_master_sdo_download(ec_master_t
     // schedule request.
     list_add_tail(&request.list, &slave->sdo_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_sdo_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -3114,13 +3114,13 @@ int ecrt_master_sdo_download_complete(ec
     request.data_size = data_size;
     ecrt_sdo_request_write(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_sdo_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n", slave_position);
         ec_sdo_request_clear(&request);
         return -EINVAL;
@@ -3132,21 +3132,21 @@ int ecrt_master_sdo_download_complete(ec
     // schedule request.
     list_add_tail(&request.list, &slave->sdo_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_sdo_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -3187,13 +3187,13 @@ int ecrt_master_sdo_upload(ec_master_t *
     ecrt_sdo_request_index(&request, index, subindex);
     ecrt_sdo_request_read(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_sdo_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         ec_sdo_request_clear(&request);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n", slave_position);
         return -EINVAL;
@@ -3204,21 +3204,21 @@ int ecrt_master_sdo_upload(ec_master_t *
     // schedule request.
     list_add_tail(&request.list, &slave->sdo_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_sdo_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -3278,13 +3278,13 @@ int ecrt_master_write_idn(ec_master_t *m
     request.data_size = data_size;
     ec_soe_request_write(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_soe_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 slave_position);
         ec_soe_request_clear(&request);
@@ -3296,21 +3296,21 @@ int ecrt_master_write_idn(ec_master_t *m
     // schedule SoE write request.
     list_add_tail(&request.list, &slave->soe_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             // abort request
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_soe_request_clear(&request);
             return -EINTR;
         }
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -3345,13 +3345,13 @@ int ecrt_master_read_idn(ec_master_t *ma
     ec_soe_request_set_idn(&request, idn);
     ec_soe_request_read(&request);
 
-    if (down_interruptible(&master->master_sem)) {
+    if (ec_lock_down_interruptible(&master->master_sem)) {
         ec_soe_request_clear(&request);
         return -EINTR;
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
         ec_soe_request_clear(&request);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n", slave_position);
         return -EINVAL;
@@ -3362,21 +3362,21 @@ int ecrt_master_read_idn(ec_master_t *ma
     // schedule request.
     list_add_tail(&request.list, &slave->soe_requests);
 
-    up(&master->master_sem);
+    ec_lock_up(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        down(&master->master_sem);
+        ec_lock_down(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            up(&master->master_sem);
+            ec_lock_up(&master->master_sem);
             ec_soe_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        up(&master->master_sem);
+        ec_lock_up(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
diff --git a/master/master.h b/master/master.h
--- a/master/master.h
+++ b/master/master.h
@@ -43,16 +43,11 @@
 #include <linux/wait.h>
 #include <linux/kthread.h>
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-#include <linux/semaphore.h>
-#else
-#include <asm/semaphore.h>
-#endif
-
 #include "device.h"
 #include "domain.h"
 #include "ethernet.h"
 #include "fsm_master.h"
+#include "locks.h"
 #include "cdev.h"
 
 #ifdef EC_RTDM
@@ -206,7 +201,7 @@ struct ec_master {
     ec_rtdm_dev_t rtdm_dev; /**< RTDM device. */
 #endif
 
-    struct semaphore master_sem; /**< Master semaphore. */
+    ec_lock_t master_sem; /**< Master semaphore. */
 
     ec_device_t devices[EC_MAX_NUM_DEVICES]; /**< EtherCAT devices. */
     const uint8_t *macs[EC_MAX_NUM_DEVICES]; /**< Device MAC addresses. */
@@ -215,7 +210,7 @@ struct ec_master {
                                 ec_master_num_devices(), because it may be
                                 optimized! */
 #endif
-    struct semaphore device_sem; /**< Device semaphore. */
+    ec_lock_t device_sem; /**< Device semaphore. */
     ec_device_stats_t device_stats; /**< Device statistics. */
 
     ec_fsm_master_t fsm; /**< Master state machine. */
@@ -254,13 +249,13 @@ struct ec_master {
 
     unsigned int scan_busy; /**< Current scan state. */
     unsigned int allow_scan; /**< \a True, if slave scanning is allowed. */
-    struct semaphore scan_sem; /**< Semaphore protecting the \a scan_busy
+    ec_lock_t scan_sem; /**< Semaphore protecting the \a scan_busy
                                  variable and the \a allow_scan flag. */
     wait_queue_head_t scan_queue; /**< Queue for processes that wait for
                                     slave scanning. */
 
     unsigned int config_busy; /**< State of slave configuration. */
-    struct semaphore config_sem; /**< Semaphore protecting the \a config_busy
+    ec_lock_t config_sem; /**< Semaphore protecting the \a config_busy
                                    variable and the allow_config flag. */
     wait_queue_head_t config_queue; /**< Queue for processes that wait for
                                       slave configuration. */
@@ -270,7 +265,7 @@ struct ec_master {
 
     struct list_head ext_datagram_queue; /**< Queue for non-application
                                            datagrams. */
-    struct semaphore ext_queue_sem; /**< Semaphore protecting the \a
+    ec_lock_t ext_queue_sem; /**< Semaphore protecting the \a
                                       ext_datagram_queue. */
 
     ec_datagram_t ext_datagram_ring[EC_EXT_RING_SIZE]; /**< External datagram
@@ -297,7 +292,7 @@ struct ec_master {
     struct list_head eoe_handlers; /**< Ethernet over EtherCAT handlers. */
 #endif
 
-    struct semaphore io_sem; /**< Semaphore used in \a IDLE phase. */
+    ec_lock_t io_sem; /**< Semaphore used in \a IDLE phase. */
 
     void (*send_cb)(void *); /**< Current send datagrams callback. */
     void (*receive_cb)(void *); /**< Current receive datagrams callback. */
diff --git a/master/module.c b/master/module.c
--- a/master/module.c
+++ b/master/module.c
@@ -61,7 +61,7 @@ static unsigned int backup_count; /**< N
 static unsigned int debug_level;  /**< Debug level parameter. */
 
 static ec_master_t *masters; /**< Array of masters. */
-static struct semaphore master_sem; /**< Master semaphore. */
+static ec_lock_t master_sem; /**< Master semaphore. */
 
 dev_t device_number; /**< Device number for master cdevs. */
 struct class *class; /**< Device class. */
@@ -101,7 +101,7 @@ int __init ec_init_module(void)
 
     EC_INFO("Master driver %s\n", EC_MASTER_VERSION);
 
-    sema_init(&master_sem, 1);
+    ec_lock_init(&master_sem);
 
     if (master_count) {
         if (alloc_chrdev_region(&device_number,
@@ -484,7 +484,7 @@ ec_device_t *ecdev_offer(
         master = &masters[i];
         ec_mac_print(net_dev->dev_addr, str);
 
-        if (down_interruptible(&master->device_sem)) {
+        if (ec_lock_down_interruptible(&master->device_sem)) {
             EC_MASTER_WARN(master, "%s() interrupted!\n", __func__);
             return NULL;
         }
@@ -500,7 +500,7 @@ ec_device_t *ecdev_offer(
 
                 ec_device_attach(&master->devices[dev_idx],
                         net_dev, poll, module);
-                up(&master->device_sem);
+                ec_lock_up(&master->device_sem);
 
                 snprintf(net_dev->name, IFNAMSIZ, "ec%c%u",
                         ec_device_names[dev_idx != 0][0], master->index);
@@ -509,7 +509,7 @@ ec_device_t *ecdev_offer(
             }
         }
 
-        up(&master->device_sem);
+        ec_lock_up(&master->device_sem);
 
         EC_MASTER_DBG(master, 1, "Master declined device %s.\n", str);
     }
@@ -543,27 +543,27 @@ ec_master_t *ecrt_request_master_err(
     }
     master = &masters[master_index];
 
-    if (down_interruptible(&master_sem)) {
+    if (ec_lock_down_interruptible(&master_sem)) {
         errptr = ERR_PTR(-EINTR);
         goto out_return;
     }
 
     if (master->reserved) {
-        up(&master_sem);
+        ec_lock_up(&master_sem);
         EC_MASTER_ERR(master, "Master already in use!\n");
         errptr = ERR_PTR(-EBUSY);
         goto out_return;
     }
     master->reserved = 1;
-    up(&master_sem);
+    ec_lock_up(&master_sem);
 
-    if (down_interruptible(&master->device_sem)) {
+    if (ec_lock_down_interruptible(&master->device_sem)) {
         errptr = ERR_PTR(-EINTR);
         goto out_release;
     }
 
     if (master->phase != EC_IDLE) {
-        up(&master->device_sem);
+        ec_lock_up(&master->device_sem);
         EC_MASTER_ERR(master, "Master still waiting for devices!\n");
         errptr = ERR_PTR(-ENODEV);
         goto out_release;
@@ -572,14 +572,14 @@ ec_master_t *ecrt_request_master_err(
     for (; dev_idx < ec_master_num_devices(master); dev_idx++) {
         ec_device_t *device = &master->devices[dev_idx];
         if (!try_module_get(device->module)) {
-            up(&master->device_sem);
+            ec_lock_up(&master->device_sem);
             EC_MASTER_ERR(master, "Device module is unloading!\n");
             errptr = ERR_PTR(-ENODEV);
             goto out_module_put;
         }
     }
 
-    up(&master->device_sem);
+    ec_lock_up(&master->device_sem);
 
     if (ec_master_enter_operation_phase(master)) {
         EC_MASTER_ERR(master, "Failed to enter OPERATION phase!\n");
diff --git a/master/slave_config.c b/master/slave_config.c
--- a/master/slave_config.c
+++ b/master/slave_config.c
@@ -192,7 +192,7 @@ int ec_slave_config_prepare_fmmu(
 
     fmmu = &sc->fmmu_configs[sc->used_fmmus];
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     ec_fmmu_config_init(fmmu, sc, domain, sync_index, dir);
 
 #if 0 //TODO overlapping PDOs
@@ -225,7 +225,7 @@ int ec_slave_config_prepare_fmmu(
 #endif
 
     sc->used_fmmus++;
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
 
     return fmmu->logical_domain_offset;
 }
@@ -650,18 +650,18 @@ int ecrt_slave_config_pdo_assign_add(ec_
         return -EINVAL;
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
 
     pdo = ec_pdo_list_add_pdo(&sc->sync_configs[sync_index].pdos, pdo_index);
     if (IS_ERR(pdo)) {
-        up(&sc->master->master_sem);
+        ec_lock_up(&sc->master->master_sem);
         return PTR_ERR(pdo);
     }
     pdo->sync_index = sync_index;
 
     ec_slave_config_load_default_mapping(sc, pdo);
 
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
     return 0;
 }
 
@@ -678,9 +678,9 @@ void ecrt_slave_config_pdo_assign_clear(
         return;
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     ec_pdo_list_clear_pdos(&sc->sync_configs[sync_index].pdos);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
 }
 
 /*****************************************************************************/
@@ -706,10 +706,10 @@ int ecrt_slave_config_pdo_mapping_add(ec
             break;
 
     if (pdo) {
-        down(&sc->master->master_sem);
+        ec_lock_down(&sc->master->master_sem);
         entry = ec_pdo_add_entry(pdo, entry_index, entry_subindex,
                 entry_bit_length);
-        up(&sc->master->master_sem);
+        ec_lock_up(&sc->master->master_sem);
         if (IS_ERR(entry))
             retval = PTR_ERR(entry);
     } else {
@@ -737,9 +737,9 @@ void ecrt_slave_config_pdo_mapping_clear
             break;
 
     if (pdo) {
-        down(&sc->master->master_sem);
+        ec_lock_down(&sc->master->master_sem);
         ec_pdo_clear_entries(pdo);
-        up(&sc->master->master_sem);
+        ec_lock_up(&sc->master->master_sem);
     } else {
         EC_CONFIG_WARN(sc, "PDO 0x%04X is not assigned.\n", pdo_index);
     }
@@ -985,9 +985,9 @@ int ecrt_slave_config_sdo(ec_slave_confi
         return ret;
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     list_add_tail(&req->list, &sc->sdo_configs);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
     return 0;
 }
 
@@ -1070,9 +1070,9 @@ int ecrt_slave_config_complete_sdo(ec_sl
         return ret;
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     list_add_tail(&req->list, &sc->sdo_configs);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
     return 0;
 }
 
@@ -1139,9 +1139,9 @@ ec_sdo_request_t *ecrt_slave_config_crea
     memset(req->data, 0x00, size);
     req->data_size = size;
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     list_add_tail(&req->list, &sc->sdo_requests);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
 
     return req;
 }
@@ -1182,9 +1182,9 @@ ec_reg_request_t *ecrt_slave_config_crea
         return ERR_PTR(ret);
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     list_add_tail(&reg->list, &sc->reg_requests);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
 
     return reg;
 }
@@ -1224,9 +1224,9 @@ ec_voe_handler_t *ecrt_slave_config_crea
         return ERR_PTR(ret);
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     list_add_tail(&voe->list, &sc->voe_handlers);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
 
     return voe;
 }
@@ -1307,9 +1307,9 @@ int ecrt_slave_config_idn(ec_slave_confi
         return ret;
     }
 
-    down(&sc->master->master_sem);
+    ec_lock_down(&sc->master->master_sem);
     list_add_tail(&req->list, &sc->soe_configs);
-    up(&sc->master->master_sem);
+    ec_lock_up(&sc->master->master_sem);
     return 0;
 }
 
